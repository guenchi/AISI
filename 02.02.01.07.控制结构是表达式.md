## 控制结构是表达式

&ensp; &ensp;Scheme 的控制结构是表达式，并返回值。if 表达式和 C 的 if-then 语句很像，但“then"分支和“else”分支也都是带返回值的表达式；if 表达式返回它求值的子表达式中的任何一个。

&ensp; &ensp;比如：
(if (< a b)

&ensp; &ensp; a

&ensp; &ensp; b)


&ensp; &ensp;返回变量 a 或变量 b 的值，取决于谁小（如果相等，则返回 b 的值）。如果你熟悉 C 中的条件表达式，这就像是像是 (a < b) ? a : b 。在 Scheme 中，不需要 if 语句和类似 if 的三元运算符表达式, 因为 if“语句”是表达式。

&ensp; &ensp;注意，即使每一个表达式都有值，也并不需要用到所有的值 —— 你可以忽略掉 if 表达式的值。if 特殊形式因此可被用于控制执行的内容，或返回一个值，或同时使用两者。这取决于你。

&ensp; &ensp;返回值设定的一致性意味着我们从来都不必显式使用返回语句，因此 Scheme 没有它们。假设我们想要写一个返回两个数中的最小值的函数 min，在 C 中，我们可能这么写：

int min(int a, int b)

{

&ensp; &ensp; if (a < b)

&ensp; &ensp; &ensp; &ensp; return a;

&ensp; &ensp; else

&ensp; &ensp; &ensp; &ensp; return b;

}

&ensp; &ensp;在 Scheme 中，我们可以这样做：

(define (min a b)

&ensp; (if (< a b)

&ensp; &ensp; a

&ensp; &ensp; b))


&ensp; &ensp;不论取哪条分支，相应的变量（a 或 b)的值会被作为 if 分支的值返回，同时也是作为整个 if 表达式的值返回，这也作为过程调用的返回值。

&ensp; &ensp;当然，你也可以写不带 else 子句的单分支 if 。

(if (some-test)

&ensp; &ensp; (some-ation))

&ensp; &ensp;如果条件为假，单分支 if 的返回值是不确定的，如果你对返回值感兴趣，你应该使用两个分支的 if ，并显式确定两者应返回的东西。

&ensp; &ensp;注意到控制流是从上往下的，通过表达式的嵌套 —— if 控制着哪条子表达式被求值，这就像大多数语言中的控制语句的嵌套一样。值从表达式返回到调用方，像大多数语言中表达式的嵌套。

&ensp; &ensp;你可以使用 begin 写出其他表达式的有序序列，例如：

(begin (foo)

&ensp; &ensp; &ensp; &ensp; (bar))



&ensp; &ensp;先调用 foo 再调用 bar ，就控制流而言，一个 (begin ... ) 表达式非常像 Pascal 中的 begin ... end 块，或 C 中的 { ... } 块。（我们不需要一个 end 关键字，因为括回做了相同的工作。）

&ensp; &ensp;然而， Scheme 的 begin 表达式并不仅仅是代码块，因为它们是带返回值的表达式。begin 返回序列中的最后一个表达式的值。例如，上面的 begin 表达式返回调用 bar 返回的值。

&ensp; &ensp;过程的内主体像 begin 一样运作。如果其中包含几个表达式，它们会被顺序求值，而且最后一个表达式的值会作为过程调用的返回值。

&ensp; &ensp;下面是一个过程 baz， 它调用 foo,，然后调用 bar 并返回对 bar 的调用的结果。

(define (baz)

&ensp; &ensp; (foo)

&ensp; &ensp; (bar)）
