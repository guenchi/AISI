## 本书的结构

这本书的结构反映了它的教导倾向，而不是任何大的概念组合。在接下来的三章，观点会被以我认为最容易学习的方式介绍。每一章或多或少的介绍了一些相关的观点，带有短小的代码示例，并以更多表现为什么观点是有用的 Scheme 程序的例子作结。之后的章节会介绍相对独立的话题。

章节 "简介" 描述了一些 Scheme 基础特性，包括一些语法，并给出 Scheme 能够被像大多数编程语言一样使用的例子 —— 在使用 Scheme 时，你不会放弃很多，转换也不难。

章节 "使用 Scheme (A Tutorial)" 给出了一个 Scheme 编程的指导，被设计为在有一个运行的 Scheme 系统和交互式测试例子时使用。

章节 "写一个解释器" 展示了一个 Scheme 子集的解释器。

章节 “环境和过程” 描述了 Scheme 的绑定环境和过程，并展示了在一个过程为一等公民，块结构，不定范围（垃圾回收）的语言中过程抽象如何能变得非常强大。之后它会展示一个上一章中解释器的绑定环境和过程的实现，并展示如何以相当复杂的方式使用 Scheme 的绑定和过程定义构造。

章节 "Scheme 中的递归" 讨论递归，尤其是尾递归。

章节 "准引用和宏" 展现了准引用，一种构造复杂数据类型和定型数据结构变体的方法，之后展现宏，一种在 Scheme 中定义你自己的"特殊形式"的工具。宏让你定义自己的控制结构，像是对象系统的数据结构系统，等等。（如果你已经被 C 或 Lisp 的宏的问题吓到过，不用担心 —— Scheme 宏解决了老版宏系统的主要问题。宏是有趣的，因为它们经常被用在实现 Scheme 自己上。它们允许你在一个层中构造语言实现，其中大部分语言都是用语言本身编写的，从被编译器理解的核心语言启动。

章节 "其他有用的特性" 展现了一系列杂乱的 Scheme 特性，它们在编写真正的程序时是有用的。它们不是 Scheme 的概念核心，但任何有用的语言都应该具有它们。

章节 "记录和面向对象"...

章节 "call-with-current-continuation" 讨论了第一等继续，在 Scheme 中最强大的控制结构。Continuation允许你捕捉活跃栈的状态（一系列），在程序执行时返回这个状态给一个给定指针。Continuations 在概念上是怪诞的，不应被轻易使用，但在回溯，线程等方面表现出色。

章节 "一个简单的 Scheme 编译器" 展示了一个碰巧是一个简单 Scheme 编译器的 Scheme 程序例子。这是一个玩具编译器，但也算是一个真正的编译器，带有所有 Scheme 编译器的基本特征，但在执行表计划技术，存储管理方面，仅仅提供最少的支持。

