## 本书的结构

&ensp;&ensp;&ensp;&ensp;这本书的结构反映了它的教程意图，而不是任何强大的概念分组。在接下来的三章，我会以我认为最容易学习的顺序介绍一些想法。每一章或多或少地介绍了一些相关的想法，带有短小的代码示例，最后还提供了更多的 Scheme 程序实例，来说明为什么这些想法是有用的。之后的章节会介绍相对独立的主题。

&ensp;&ensp;&ensp;&ensp;“简介”这一节描述了一些 Scheme 基础特性，包括一些语法，并给出了代码示例，以表明 Scheme 可以像大多数编程语言一样使用 —— 使用 Scheme 时，你不会放弃很多，也不难切换。

&ensp;&ensp;&ensp;&ensp;“使用 Scheme (A Tutorial)”这一节 给出了 Scheme 编程的教程，用于运行 Scheme 系统和交互式测试例子。

&ensp;&ensp;&ensp;&ensp;“写一个解释器”一节展示了一个 Scheme 子集的解释器。

&ensp;&ensp;&ensp;&ensp;“环境和过程”一节描述了 Scheme 的绑定环境和过程，并展示了在一个过程为一等公民，不定范围块结构，（垃圾回收）的语言中，过程抽象如何能变得非常强大。之后它会展示一个上一章中解释器的绑定环境和过程的实现，并演示如何以相当复杂的方式使用 Scheme 的绑定和过程定义构造。

&ensp;&ensp;&ensp;&ensp;“Scheme 中的递归”一节讨论递归，尤其是尾递归。

&ensp;&ensp;&ensp;&ensp;“准引用和宏”一节展现了准引用，一种构造复杂数据类型和定型数据结构变体的方法，之后介绍宏，一种在 Scheme 中定义你自己的"特殊形式"的工具。宏允许你定义自己的控制结构，像是对象系统的数据结构系统，等等。（如果你已经被 C 或 Lisp 的宏的问题吓倒过，不用担心 —— Scheme 宏解决了旧版宏系统的主要问题。宏是有趣的，因为它们经常被用在 Scheme 本身的实现上。它们允许你在一个层中构造语言实现，其中大部分语言都是用语言本身编写的，方法是从被编译器理解的核心语言启动。

&ensp;&ensp;&ensp;&ensp;“其他有用的特性”一节展现了一系列杂乱的 Scheme 特性，它们在编写真正的程序时非常有用。它们不是 Scheme 的概念核心，但任何有用的语言都应该具有它们。

&ensp;&ensp;&ensp;&ensp;章节 “记录和面向对象”...

&ensp;&ensp;&ensp;&ensp;章节 "call-with-current-continuation" 讨论了第一等延续，这是 Scheme 中最强大的控制结构。延续 允许你捕捉活跃堆栈的状态（排序），并返回到该状态以在程序执行的给定点恢复。延续 在概念上是奇怪的，不应被轻易使用，但在回溯，线程等方面表现出色。

&ensp;&ensp;&ensp;&ensp;章节“一个简单的 Scheme 编译器”展示了一个 Scheme 示例程序，它碰巧是个简单的 Scheme 编译器。这是一个玩具编译器，但也算是一个真正的编译器，带有所有 Scheme 编译器的基本特征，但在执行表计划技术，存储管理方面，仅仅提供最少的支持。

