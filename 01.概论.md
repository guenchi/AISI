概论
===

本书为程序员们提供了一份对 Scheme 的介绍 —— 不是给新手，而是给已经知道如何编程（至少一点点）并对学习 Scheme 感兴趣的人。

### 1.[ Scheme: 小而强大的语言](#1):Scheme: A Small But Powerful Language

### 2.[本书的对象](#2): Who is this Book For?

### 3.[为什么是 Scheme ?](#3): Why Scheme?

### 4.[本书不是...](#4): What this Book Is Not?

### 5.[本书的结构](#5): Structure of this Book

<h1 id="1"> </h1>

### 1.Scheme:小而强大的语言

Scheme 是一种干净，小巧但功能强大的语言，一种通用编程语言，一种脚本语言，一种嵌入应用的扩展语言，或是其他任何东西。

Scheme 在设计上适用于各种实现方法，而且存在许多实现 —— 大部分都是自由软件。有直接的解释器（如 BASIC 或 Tcl）, 快速机器码的编译器（像是 C 或 Pascal），以及可移植的解释虚拟机代码的编译器（像是 Java）。

存在几种 Scheme 的扩展实现，包括我们自己的 RScheme 系统，它是一种具有集成对象系统和强大可扩展性功能的强可移植 Scheme 实现。

这是关于 Scheme，Scheme 实现和 Rscheme 语言及其实现的三个计划文档中的第一个。当它们都被完成后，我可能会把它们合并为一大本书。它们都将采用 Texinfo 格式，以便于打印、硬拷贝、作为在线浏览的信息文档（使用 Info 浏览器，或 Emacs 编辑器的 Info 系统）或自动转换为 HTML 格式，以便使用 Web 浏览器进行浏览。不管以哪一种方式阅读，欢迎来到 Scheme。

<h2 id="2"> </h2>

### 2.本书的对象

本书的对象是对 Scheme 工作原理感兴趣的人，就语言设计这一方面对 Scheme 有兴趣的人，或只是对使用 Scheme 感兴趣的人。

这些目的并不矛盾，因为学习 Scheme 的最好方法之一 —— 以及程序语言设计的重要原则 —— 就是明白如何实现 Scheme。在 Scheme 中，我会通过展示两个简单的 Scheme 子集的解释器和一个简单的编译器来展示 Scheme 的强大功能。Scheme 的编译器可以是令人惊奇地简单和容易理解。

这是一种相当传统的方法，由 Abelson 和 Sussman 在 *Structure and Interpretation of Computer Programs* 这一广泛使用的优秀的入门编程书中首创。这种方法在其他几本 Scheme 编程的入门书籍中或多或少地得到了遵循。不过，这些书大多是给初学者的。虽然我认为 Scheme 是一种优秀的第一语言，但很多人却不愿意翻翻入门书来学习 Scheme，而不得不忍受学习 C，Pascal 或其他语言的痛苦。

我的方法在几个方面和目前大部分的书不同。

我会从略介绍基础编程知识 —— 例如，我假设你已经了解了什么是变量，什么是递归。

我会采用比其他 Scheme 书籍作者更加具体的方法，因为我发现许多学生觉得这样更容易理解。时不时地我会降到低于编程语言的底层，并告诉你大多数的实际实现是怎样的。我发现具体有助于消除许多学生，以及我自己心中的模糊。

我不会从函数式编程的角度出发来假装 Scheme 通过重写表达式来执行。（如果这对你没有任何意义，那就不要担心！）

我把 Scheme 视作一种弱面向对象语言的特例。谈到弱面向对象，我并不是指它在继承等意义上是面向对象的 —— 即使一些 Scheme 扩展版本做到了。我只是指，在这种语言中，值（记录，等等）是数据对象，它的标识（identities）很重要 —— 也就是说，你可以比较指向两个对象的指针，来判断它们是否为完全相同（very same）的对象，不只是判断它们是否有着相同的状态 —— 对象可能具有可变（可更改）状态。（这种观点在 RScheme，一种是 Scheme 的完全面向对象的语言中得到了进一步的发展。但这是另外一本书了，还没被写出来。）

一些人可能不喜欢这种方法，因为我在一开头就讲到了状态和赋值。在 Scheme 中随意使用赋值通常被认为是一种不好的风格，主要写"函数式"或"应用式"程序则被认为是好的风格。我同意在 Scheme 主要使用函数式编程是正确的做法，但我的目的是在一开始就明确语言的语义，让新的 Schemer 们明白 Scheme 只是一种相当普通的编程语言，即使它异常干净和富有表达力。我在讲授 Scheme 时的经验使我确信，许多人从一开始就接触赋值中获益；它讲清了变量和变量绑定的基础。当其他的东西更清楚的时候，我会在接下来讨论编程样式。

如果你曾尝试过学习 Lisp 或 Scheme，但并未深入，这本书可能有助于你。许多人学习 Scheme 或 Lisp，就像鸭子戏水一样简单。然而，有些人不是，我认为这往往是因为学习材料的展现方法的问题 —— 学习 Lisp 或 Scheme 一点都不难。在本书中，我尝试对一些事情给予不同于常规的解释，从而避免有些人从现有书籍中学到的毛病。具体的解释可能有助于克服对这些语言的不熟悉感。Scheme 真的只是一种普通的编程语言，但同时又有着能以特殊方式使用的强大功能。

如果你是个程序语言设计者，但不擅长于 Scheme 或 Lisp，这本书对于讲清楚这些语言的本质可能有所帮助。我确信，在 Lisp 世界和"传统的"命令式编程语言世界间存在着破坏性的裂痕。这在很大程度上是不同社区的使用的不同词汇导致。最近的 Scheme 发展并未得到其他语言设计者的广泛称赞。（这个话题会在本系列的其他文档中进一步阐述。）即便是古老的 Lisp 特性，例如宏，也还没有被大多语言设计者们恰当地理解，他们碰到的问题在 Scheme 中得到了实质性的解决。

如果你是个编程语言实现者，或者教授编程语言的实现，这本书也可能有用。（我在有关语言和实现的课程中用到了它。）我会介绍 Scheme 的解释器和编译器。Scheme 是讲授编程语言实现原则的优秀工具，因为它的语法简单，从简单的解释器到复杂的解释器有一个直接的演变，从简单的解释器到编译器又有一个直接的转变。这支持了以最少无关细节教授语言实现的原则。

<h2 id="3"> </h2>

### 3.为什么是 Scheme

Scheme 是一种非常好的语言，用于实现语言，或用于通用的转换编程 （即编写编写程序的程序），或是用于编写易于扩展或自定义的程序。让实现 Scheme 有吸引力的 Scheme 特性也让它适用于各种事物，包括编写脚本，构建新语言和特定于应用程序的编程环境，等等。

[随着你学习 Scheme，你很可能意识到，所有有趣的程序实际上最终都是特定于应用程序的编程环境 ...]

大多数 Scheme 系统是交互式的，允许你逐步开发和测试程序的各个部分。从这方面讲，它非常像 BASIC 或 Tcl —— 但它更加干净和有表现力。Scheme 也能够被编译，且运行迅速。这让它能像 BASIC 或 Tcl 一样开发，但速度仍然像 C 那么快。（Scheme 通常不如 C 快，但如果有一个好的编译器，它通常不会慢很多。）所以，如果你是个寻找不那么灵活/古板的语言的 BASIC 或 Tcl 程序员，Scheme 也许会是你的选择。

不同于大多数交互式语言，Scheme 是精心设计的：它并不是被一些鼠目寸光的人粗制滥造的，创造之后又超出合理使用范围的组装机（kludge）。它从一开始就被设计为通用语言，结合了两种早期语言的最好特性。它是对 Lisp 的彻底修订，合并了 Lisp 和 Algol （ C，Pascal 及其他语言的祖先）的最佳特性。

（这正是为什么 Scheme 已被几个组织作为像 Tcl 和 Perl 一样的蹩脚语言的替代品。自由软件基金会（FSF）的 Guile 扩展语言就是基于 Scheme 的。UNIX 的脚本 Scheme Shell （scsh）也是如此。CAD 框架计划已经接受 Scheme 作为控制计算机辅助设计工具。Dylan 语言也是基于 Scheme 的，虽然有着不同的语法和扩展。）

如果你想学习 Lisp，Scheme 是个不错的开始。Common Lisp 是个大型的，有点杂乱的语言，从 Scheme 开始学习很可能是最简单的。然后你可以把 Common Lisp 理解为对 Scheme 的一系列扩展（和显著的混淆）。Common Lisp 中一些最好的特性是从 Scheme 中抄过去的。

如果你想从函数式编程的风格中学到些什么，你可以在 Scheme 中做到这一点 —— 大多数优秀的 Scheme 程序在基本上是函数式的，因为这就是做许多趣事的最简单的方法。

如果你只是想把编程学的更好，Scheme 会带给你看待编程的新的角度。许多人会在 Scheme 中写出程序的原型，因为这是如此简单，即使最后他们不得为了满足雇主而用其他语言来重写代码。

### 为什么现在是 Scheme

Scheme 并不是一种新的语言 —— 它已经存在并缓慢演变了 20 多年。

Scheme 的演变非常缓慢，因为为 Scheme 的标准制定者们非常保守 —— 只有在人们就特性如何运作达成近乎普遍的共识时，特性才会被标准化。重点被放在质量上，而不是工业可用性。

这一政策导致了两个结果。第一，Scheme 是一种美丽的，精心设计的语言。第二，Scheme 一直“落后于形势”，缺少一些在通用语言中有用的特性。然而，渐渐地，Scheme 已从只适用于教学概念的小语言，发展成了一种非常有用的语言。

Scheme 最重要的新特性（在我看来）是词法作用域的（“卫生的”）宏，
它允许以可移植的，高效的方式实现语言特性。这让 Scheme 保持小体型，但又允许将对基本语言有用的扩展编写成库，而不会造成显著的性能损失。

<h2 id="4"> </h2>

### 4.本书不是...

这本书并不是 Scheme 的语言定义，也不是使用任何 Scheme 实现的手册。有一份免费的 Scheme 语言定义文档，叫做 Revised Scheme Report，（也有 IEEE 标准）可通过互联网轻易获得。我建议获得这份报告并打印出来，或者使用 Web 浏览器浏览 HTML 版本。（ http://www.cs.indiana.edu/scheme-repository/doc.standards.html ）它不是很大，因为 Scheme 是一个相当小的语言，我也推荐看一看你使用的特定实现的文档。

另一方面，这本书在多数情况下是可以当作一本语言手册的。（我设计了在线索引，一旦它更加充实，它就可以更好地达到这个目的。）它清晰地描述了标准 Scheme 的所有重要特性，大多数情况下你都用得着。因为 Scheme 足够干净且“正交”（orthogonal） —— 大多数特性不会以令人惊讶的方式交互，所以，如果你理解了 Scheme，并做着“Scheme 式”的事，Scheme 会按照你期待的去做。

有关 Scheme、特定 Scheme 实现的详细信息等，请参阅 usenet 新闻组 comp.lang.scheme 上的 FAQ 列表。它可从 Scheme 仓库通过匿名互联网 ftp 从 ftp.cs.indiana.edu 在目录 pub/scheme-repository 下访问。或者，如果你是万维网（World Wide Web）用户，请在 http://www.cs.indiana.edu/scheme-repository 访问 Scheme 仓库。Scheme 仓库包含几个免费的 Scheme 实现，以及各种有用的程序，库和文章。

<h2 id="5"> </h2>

### 5.本书的结构

这本书的结构反映了它的教学意图，而不是任何强大的概念分组。在接下来的三章，我会以我认为最容易学习的顺序介绍一些概念。每一章或多或少地介绍了一些相关的概念，并带有短小的代码示例，最后还提供了更多的 Scheme 程序实例，来说明为什么这些概念是有用的。之后的章节会介绍相对独立的主题。

“简介”这一章描述了一些 Scheme 基础特性，包括一些语法，并给出了代码示例，以表明 Scheme 可以像大多数编程语言一样使用 —— 使用 Scheme 时，你不会丢弃很多使用其他语言的习惯，也不难与其他的语言切换。

“使用 Scheme”这一章给出了一份 Scheme 编程的教程，它用于运行 Scheme 系统和交互式测试例子。

“写个解释器”一章展示了一个 Scheme 子集的解释器。

“环境和过程”一节描述了 Scheme 的绑定环境和过程，并展示了在一个过程为一等公民，不定范围块结构，（垃圾回收）的语言中，过程抽象如何能变得非常强大。之后它会展示一个上一章中解释器的绑定环境和过程的实现，并演示如何以相当复杂的方式使用 Scheme 的绑定和过程定义构造。

“Scheme 中的递归”一章讨论递归，尤其是尾递归。

“准引用和宏”一章展现了准引用，一种构造复杂数据类型和定型数据结构变体的方法，之后介绍宏，一种在 Scheme 中定义你自己的"特殊形式"的工具。宏允许你定义自己的控制结构，像是对象系统的数据结构系统，等等。（如果你已经被 C 或 Lisp 的宏的问题吓倒过，不用担心 —— Scheme 宏解决了旧版宏系统的主要问题。宏是有趣的，因为它们经常被用在 Scheme 本身的实现上。通过从被编译器理解的核心语言的驱动，宏允许你将语言实现构建在一个层上，Scheme 的绝大部分都是通过它自己编写的。（原文：They allow the language implementation to be structured in a layers, with most of the language written in the language itself, by bootstrapping up from a very small core language understood by the compiler.）

“其他有用的特性”一节展现了一系列杂乱的 Scheme 特性，它们在编写真正的程序时非常有用。它们不是 Scheme 的概念核心，但任何有用的语言都应该具有它们。

章节 “记录和面向对象”...

章节 "call-with-current-continuation" 讨论了一等延续，这是 Scheme 中最强大的控制结构。延续允许你捕捉活跃堆栈的状态（排序），并返回到该状态以在程序执行的给定点恢复。延续在概念上是古怪的，不应被轻易使用，但它在回溯，线程等方面表现出色。

章节“一个简单的 Scheme 编译器”展示了一个 Scheme 示例程序，它是个简单的 Scheme 编译器。这是一个玩具编译器，但也算是一个真正的编译器，带有所有 Scheme 编译器的基本特征，但在标记化（tokenization），内存管理方面，仅仅提供最少的支持。
