## 本书的对象

本书的对象是对 Scheme 如何工作感兴趣的人，或是就程序语言设计而言对 Scheme 有兴趣的人，或仅仅是对使用 Scheme 感兴趣的人。

这些目的之间不存在矛盾，因为一种最好的学习 Scheme 的方法 —— 也是程序语言设计的重要原则 —— 是学会如何实现 Scheme。在 Scheme 中，我会通过展示几个简单的 Scheme 子集的解释器和一个简单的编译器来阐明 Scheme 的强力。一个 Scheme 的编译器可以是令人惊奇地简单和容易理解。

这是一种相当传统的方法，由 Abelson 和 Sussman 在 *Structure and Interpretation of Computer Programs* ，一本广泛使用的优秀的入门编程书中首创。这种方法在其他几本 Scheme 编程的入门书中或多或少地得到了遵循。然而，这些书的大部分都是给初学者的。当我认为 Scheme 是一种优秀的初学语言时，仍有很多人不得不受学习 C ，Pascal 或其他语言的苦，而不愿意涉水一本编程入门书来学习 Scheme 。

我的方法在几个方面和大部分当下的 Scheme 书不同。

我会略过基础编程知识 —— 例如，我假设你已经了解了什么是变量，什么是递归。

我会采用比其他 Scheme 书作者更加具体的方法，因为我已经发现许多学生觉得这样更容易理解。时不时的我会降到低于编程语言的底层，并告诉你大多数语言的实际实现是怎样的。我发现具体有助于消除许多学生心中的模糊 —— 以及我自己。

我不会从函数式编程的角度出发来假设 Scheme 通过重写表达式来执行。（如果这对你没有任何意义，绝对不要担心！）

我把 Scheme 视作一种特殊的面向对象语言。谈到弱面向对象，我并不是指它在继承等意义上是面向对象的 —— 即使一些 Scheme 扩展版本做到了。我只是指值在这种语言中是重要的数据对象 —— 对此，你可以比较指向两个对象的指针，来判断它们是否为完全相同的对象，不只是判断它们是否有着相同的状态 —— 对象可能具有可变（可更改）状态。（这种观点在 RScheme ，一种恰好是 Scheme   的完全面向对象的语言中得到了更深远的发展。但这是另外一本书了，还没被写出来。）

一些人可能不喜欢这种方式，因为我在一开头就讲到了状态和赋值。在 Scheme 中随意使用赋值被广泛认为是一种不良风格，主要写"函数式"或"应用式"程序被认为是好的风格。我认为在 Scheme 主要用函数式编程是好的，但我的目的是在一开始的时候让语言的的语义清晰，让新的 Schemer 们明白 Scheme 只是一种相当普通的编程语言，即使它是不同寻常的干净和富有表达力。我在教授 Scheme 时的经验让我明白我许多人从尽早接触赋值中获益；它讲清了变量和变量捆绑的基础。当其他东西更清晰时，接下来会讨论编程风格。

如果你曾经尝试过学习 Lisp 或 Scheme ,但并未深入，这本书可能有助于你。许多人开始学习 Scheme  或 Lisp , 就像鸭子戏水一样。然而，有些人不是，我认为通常的原因是学习材料的展现方法 —— 学习 Lisp 或 Scheme 一点都不难。在这本书中，我尝试对一些事情给予不同于常规的解释，从而避免有些人从现有书籍中学到的毛病。具体的解释可能有助于克服对这些语言的不熟悉感。Scheme 真的只是一种普通的编程语言，但同时又有着能以特殊方式使用的强大功能。

如果你是个程序语言设计者，但不擅于 Scheme 或 Lisp , 这本书对于讲清楚这些语言到底是什么有帮助。我确信在 Lisp 世界和"传统的"命令式编程语言世界间存在着破坏性的裂痕。很大程度上是由于不同社区的不同词汇。最近的 Scheme 开发并未广泛的被其他语言设计者所欣赏。（这个话题会在本系列的其他文档中进一步发展。）即便是古老的 Lisp 特性，例如宏，也还没有被大多语言设计者们恰当地理解，他们的问题在 Scheme 中已被基本解决。

如果你是个编程语言实现者，或教授编程语言实现，这本书也有用。（我在一门语言和实现的课程中用到了它。）我会展示 Scheme 的解释器和编译器。Scheem 是一种讲授编程语言实现原则的优秀工具，因为它的法简单，从简单的解释器到复杂的解释器有一个直接的演变，从简单的解释器到编译器又有一个直接的转变。这支持了以最少无关细节教授语言实现的原则。
