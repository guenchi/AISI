## 本书的对象

本书的对象是对 Scheme 工作原理感兴趣的人，就程序语言设计而言对 Scheme 有兴趣的人，或只是对使用 Scheme 感兴趣的人。

这些目的并不矛盾，因为学习 Scheme 的最好方法之一 —— 以及程序语言设计的重要原则 —— 是明白如何实现 Scheme。在 Scheme 中，我会通过展示两个简单的 Scheme 子集的解释器和一个简单的编译器来展示 Scheme 的强大功能。Scheme 的编译器可以是令人惊奇地简单和容易理解。

这是一种相当传统的方法，由 Abelson 和 Sussman 在 *Structure and Interpretation of Computer Programs*，一本广泛使用的优秀的入门编程书中首创。这种方法在其他几本 Scheme 编程的入门书籍中或多或少地得到了遵循。不过，这些书大多是给初学者的。虽然我认为 Scheme 是一种优秀的第一语言，仍有很多人不得不受学习 C，Pascal 或其他语言的苦，而不愿意尝试一本编程入门书来学习 Scheme。

我的方法在几个方面和目前大部分的书不同。

我会从略介绍基础编程知识 —— 例如，我假设你已经了解了什么是变量，什么是递归。

我会采用比其他 Scheme 书籍作者更加具体的方法，因为我发现许多学生觉得这样更容易理解。时不时地我会降到低于编程语言的底层，并告诉你大多数语言的实际实现是怎样的。我发现具体有助于消除许多学生心中的模糊 —— 以及我自己。

我不会从函数式编程的角度出发来假装 Scheme 通过重写表达式来执行。（如果这对你没有任何意义，绝对不要担心！）

我把 Scheme 视作一种弱面向对象语言的特例。谈到弱面向对象，我并不是指它在继承等意义上是面向对象的 —— 即使一些 Scheme 扩展版本做到了。我只是指，在这种语言中，值是数据对象，它的标识很重要 —— 也就是说，你可以比较指向两个对象的指针，来判断它们是否为完全相同（very same）的对象，不只是判断它们是否有着相同的状态 —— 对象可能具有可变（可更改）状态。（这种观点在 RScheme，一种是 Scheme 的完全面向对象的语言中得到了进一步的发展。但这是另外一本书了，还没被写出来。）

一些人可能不喜欢这种方法，因为我在一开头就讲到了状态和赋值。在 Scheme 中随意使用赋值通常被认为是一种不好的风格，主要写"函数式"或"应用式"程序则被认为是好的风格。我同意在 Scheme 主要用函数式编程是正确的做法，但我的目的是在一开始就明确语言的的语义，让新的 Schemer 们明白 Scheme 只是一种相当普通的编程语言，即使它异常干净干净和富有表达力。我在教授 Scheme 时的经验使我确信，许多人从早期接触赋值中获益；它讲清了变量和变量绑定的基础。当其他东西更清楚，我会在接下来讨论编程样式。

如果你曾尝试过学习 Lisp 或 Scheme，但并未深入，这本书可能有助于你。许多人学习 Scheme 或 Lisp，就像鸭子戏水一样简单。然而，有些人不是，我认为这往往是因为学习材料的展现方法的问题 —— 学习 Lisp 或 Scheme 一点都不难。在本书中，我尝试对一些事情给予不同于常规的解释，从而避免有些人从现有书籍中学到的毛病。具体的解释可能有助于克服对这些语言的不熟悉感。Scheme 真的只是一种普通的编程语言，但同时又有着能以特殊方式使用的强大功能。

如果你是个程序语言设计者，但不擅长于 Scheme 或 Lisp，这本书对于讲清楚这些语言的本质有所帮助。我确信，在 Lisp 世界和"传统的"命令式编程语言世界间存在着破坏性的裂痕。这在很大程度上是不同社区的使用的不同词汇导致。最近的 Scheme 发展并未得到其他语言设计者的广泛称赞。（这个话题会在本系列的其他文档中进一步阐述。）即便是古老的 Lisp 特性，例如宏，也还没有被大多语言设计者们恰当地理解，他们的问题在 Scheme 中得到了实质性的解决。

如果你是个编程语言实现者，或者教授编程语言的实现，这本书也可能有用。（我在有关语言和实现的课程中用到了它。）我会介绍 Scheme 的解释器和编译器。Scheme 是讲授编程语言实现原则的优秀工具，因为它的语法简单，从简单的解释器到复杂的解释器有一个直接的演变，从简单的解释器到编译器又有一个直接的转变。这支持了以最少无关细节教授语言实现的原则。
