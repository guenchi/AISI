简介
===

在本章，我会对 Scheme 的基础特性进行简要概括，足够开始编写一些程序。

本章会过的很快， 简要介绍 Scheme 中大约一半的想法。在之后的章节中，我会更加全面地解释和演示这些特性，并介绍其他高级特性。

本章被打算是与下一章的前半部分同时阅读，下一章包含了关于交互式使用 Scheme 的教程。当你应当翻看下一章的部分内容时，我会给出指示。在熟悉 Scheme 后，它将作为基础的参考内容。你可以参考下一章中的基本示例，并在后面的章节中了解高级技巧。

如果你精通编程语言的概念，尤其是你已经在用 Lisp 编程，你可以轻松阅读这一章，来了解 Scheme 是关于什么的。如果你精通编程语言的概念，可以直接阅读本章。

如果你想要在 Scheme 中实际编程，你必须听从指示并阅读下一章的部分内容，而不是径直读完本章。

### 1.[Scheme 是什么](#1)：What is Scheme?

### 2.[Scheme 基础特性](#2)：Basic Features of Scheme (modified last time)

### 3.[序对和表](#3)：pairs and lists

### 4.[数据结构上的递归](#4)：Recursion Over Lists and Other Data Structures

### 5.[类型和相等判定](#5)：Type and Equality Predicates

### 6.[引用和字面量](#6)：Quoting and Literals

### 7.[局部变量和词法作用域](#7)：Local Valiables and Lexical Scpoe

### 8.[过程](#8)：Procedures

### 9.[变量的再次绑定](#9)：Valuables, Bindings, and Values

### 10.[尾递归](#10)：Tail Recursion

### 11.[宏](#11)：Extending the Language

### 12.[延续](#12)：Continuations

### 13.[迭代构造](#13)：Iteration Constructs

### 14.[讨论](#14)：Introduction Discussion

<h1 id="1"> </h1>

### 1. Scheme 是什么（Hunk A）

==================================================================

Hunk A starts here:

==================================================================

首先， 一堆行话 —— 不想看就忽略掉：

Scheme 是一种词法范围的，块结构的，动态类型的，大体上的函数式语言。它是 Lisp 的变体。它有带有块结构，和不确定范围的第一等过程。它的参数按值传递， 但值就是引用。它有第一等 延续，允许构建新的控制抽象。它有词法范围（“卫生的”）宏，允许定义新的语法形式，或重新定义旧的语法形式。

如果这些现在对你毫无意义，别担心，继续向下读。

Scheme 被设计为一种交互性的和安全的语言。普通的 Scheme 系统是一个交互式程序，能让你按你想要的顺序运行 Scheme 程序的某些部分。当一个程序运行时，已有的程序不只是终止，你的数据不会消失 —— Scheme 会询问下一步做什么， 你可以检验数据或告诉 Scheme 去运行程序的另一部分。

Scheme 是安全的，因为交互式系统一般不会崩溃。如果你犯了个会导致系统崩溃的错误，Scheme 会发现它， 并询问你怎么做。它允许你检查和更改系统的状态，然后继续。这和普通的 编辑-编译-链接-运行-崩溃 周期的“批处理”编程语言相比，比如 C 和 C++，是一种非常不同的编程和调试风格。

<h2 id="2"> </h2>

### 2. Scheme 基础特性

我会把一些 Scheme 基础特性简单地讲一遍，为清晰起见，只给出少量代码示例。

#### 2.1.[表达式](#2.1)：代码由表达式构成

#### 2.2.[布尔值](#2.2)：布尔值 #t 和 #f

#### 2.3.[其他控制流结构](#2.3)：cond，and，和 or

#### 2.4.[注释](#2.4)：注释从分号开始直到行末

#### 2.5.[括号和缩进](#2.5)：关于括号和缩进的注解

#### 2.6.[值皆指针](#2.6)：所用的值在概念上是指针

#### 2.7.[自动内存管理](#2.7)：Scheme 自动内存回收

#### 2.8.[动态类型](#2.8)：对象具有类型，而变量没有

#### 2.9.[空表](#2.9)：空表对象()，也叫做空指针

<h2 id="2.1"> </h2>

#### 2.1.表达式

像 Lisp 一样，Scheme 也使用前缀表达式进行编写，使用括号进行分组。前缀意味着运算符的名称排在第一个，在运算对象（操作的内容）的前面。

在 Scheme 中，并没有对表达式（比如算术运算）和语句（像是 条件语句 或 循环语句 或 声明 ）的区分。它们都是“表达式” —— 从普遍意义上来说。

-   ##### 2.1.1.[前缀表达式](#2.1.1)：带括号的前缀表达式
    
-   ##### 2.1.2.[值和副作用](#2.1.2)：表达式会返回 值，但可能有副作用
    
-   ##### 2.1.3.[定义变量和过程](#2.1.3)：定义变量和过程
    
-   ##### 2.1.4.[定义 vs 赋值](#2.1.4)：定义命名存储空间，赋值改变存储的值
    
-   ##### 2.1.5.[大多数运算符都是过程](#2.1.5)：大多数运算符都是过程
    
-   ##### 2.1.6.[特殊形式](#2.1.6)：特殊形式不是过程
    
-   ##### 2.1.7.[控制结构是表达式](#2.1.7)：控制结构是返回 值的表达式
#|注：“返回”这个词和“值”连到一起就成了“返回值”，这是个名词，在下文中，我使用“返回 值”来表示返回了一个或多个值，使用“返回值”来表示返回值:p |#

<h2 id="2.1.1">

##### 2.1.1.前缀表达式

在 C 或 Pascal 中，对带有参数 bar 和 baz 的过程 foo 的调用被写成：

```C
foo (bar, baz);
```

但在 Scheme 中，它被写成：

```scheme
(foo bar baz)
```

请注意，过程名和参数一起在括号里。习惯它。如果你把它想成操作系统的一条 Shell 命令，比如，rm foo 或 dir bar —— 只是带上了括号分隔，它看起来就不会太奇怪了。

就像在 C 中一样，表达式可以嵌套。下面是对过程 `foo` 的调用，其中嵌套调用了过程表达式来计算参数。

```scheme
(foo (bar x) (baz y))
```

这几乎相当于 C 中的

```C
foo (bar(x), baz(y));
```

与 C 或 Pascal 一样，在实际调用过程之前，过程中的参数表达式会被求值；返回值被传递给过程。在 Scheme 术语中，我们说该过程被*应用*于实际参数。

你很快就会注意到，Scheme 中的特殊字符非常少，表达式通常用括号和空格分隔。例如，a-variable 是单个标识符，而不是减法表达式。在 Scheme 中，标识符不仅可以包含字母和数字，还可包含其他几种字符，例如 ! , ? , 和 _ 。长标识符通常由短语构成，使用连字符分割单词，来清楚地说明它们的含义；例如，你可以有一个名为 list-of-first-ten-lists 的变量。你能够在一个标识符中使用像 +，-，* ，/ 的字符，就像在 before-tax-total+tax 或 estimate-epsilon 中一样。

Scheme 对构建标识符的规则很宽松，这样导致的一个后果是空格很重要。除非特殊字符（通常是括号）使标识符之间的划分显得明显，你必须在标识符之间输入一个或多个空格（或是回车）。例如，加法表达式 (+ 1 a) 不能被写成 (+1 a) 或 (+1a) 再或是 (+ 1a) 。（它能被写成 ( + 1 a )，因为在标识符之间额外的空格会被忽略）

<h2 id="2.1.2"> </h2>

##### 2.1.2.值和副作用

Scheme 表达式结合了表达式和语句的特性。它们返回 值，但它们也可以有副作用 —— 也就是说，它们能通过赋值改变变量或对象的状态。

在 Scheme 中，变量赋值操作是 `set!`，读作“set-bang”。如果我们把 3 赋给变量 foo，我们这样写

```scheme
(set! foo 3)
```

这和 C 中的 `foo=3;` 非常像。

注意,`(set! foo 3)` 看上去像是函数调用，因为所有东西都使用前缀表达法，但这并不是一个真正的调用，这是另一种表达式。

你不应该在 Scheme 程序中使用太多赋值操作。就像我在之后解释的，这通常是不好风格的体现。我将展示怎样以一种不需要过多副作用的风格来编程。不过，如果你需要，它们就在那里。

当你编写一个修改参数值，而不仅仅是返回 值的过程时，给它一个以感叹号结尾的名字是一种好的风格。这提醒你和任何读你的代码的人，该过程会改变已经存在的东西，而不仅仅是像返回一个新的数据结构一样返回一个值。大多数改变状态的 Scheme 标准过程都以这种方式命名。

但是，大多数 Scheme 过程不会修改任何东西。例如，标准过程 `reverse` 以表作为参数并返回反序的表。也就是说它返回了原始列表的反向副本，而没有修改原始列表。如果你编写了一个返回反序的表的过程，但以修改内容的方式使之反向，你最好称之为 `reverse!` 。这警告人们被传递给 `reverse!` 的表可能会被改变。

另一个带副作用的过程例子是 `display`。`display` 接受一个值，并将其以打印的形式写入屏幕或文件。如果你给它一个参数，它会写入“标准输出”；默认情况下，这是终端或其他展示方式。

例如，如果你想要给用户展示数字 1022 的打印表示，可以使用这个表达式

```scheme
(display 1022)
```

执行此表达式的副作用是将 1022 写在用户的屏幕上。（`display` 自动将数字转化为字符串，以便你阅读。）

注意，`display` 并没有以感叹号结尾，因为它并没有对你提供的参数产生副作用。你可以给它一个数据结构，并确信它不会进行修改；`display` 当然具有副作用，但是 —— 它改变的是它将内容写入的显示屏（或文件）的状态。

`display` 相当灵活，能够写入许多常见的 Scheme 对象的打印表示，甚至是相当复杂的数据结构。

除其他外，`display` 还能打印字符串。（字符串是另一种 Scheme 对象。你可以在双引号之间写出字符串字面量，“like this”，Scheme 创建一个字符串对象来存储字符序列。

表达式 `(display "hello world")` 带有写入"hello world"到标准输出的副作用，标准输出通常是用户的显示器。

这让 `display` 在调试程序、编写小的示例及编写交互式程序中显得非常有用。相似的过程 `write` 被用于在文件中保存数据；数据能通过使用 `read` 被拷贝回内存中。

在之后的章节，我会通过传递第二参数给 `display`，告诉它在何处输入，来展示如何写入文件。就现在而言，你只需要使用带一个参数的 `display`。不要尝试传递给 `display` 几个东西，并期望它全都打印出来。

<h2 id="2.1.3"> </h2>

##### 2.1.3.定义变量和过程

可以使用 `define` 在 Scheme 中定义变量：

```scheme
(define my-variable 5)
```

这告诉 Scheme 为 my-variable 分配空间，并将存储空间的值初始化为 5。

在 Scheme 中，你总是给一个变量赋初值，这样一来，就没有像是未初始化的变量或未初始化变量错误之类的东西了。

Scheme 的值始终是指向对象的指针，所以当我们使用字面量 5 时，Scheme 将其解释为指向对象为 5 的指针。数字是可以指向的对象，就像其他任何类型的数据结构一样。（实际上，大多数 Scheme 实现都使用了一些技巧来避免数字上的指针开销，但这并未在语言水平上显示。你不必注意它。）

在上述定义之后，我们可以像这样画出结果的情况：

```
    +-------+
foo |   *---|--->5        
    +-------+
```

`define` 表达式做了三件事：

-   它向 Scheme 声明，我们将在当前作用域中得到一个名为 foo 的变量。（我会在稍后讨论作用域。）
    
-   它告诉 Scheme 为变量分配存储空间。存储空间被称作绑定 —— 我们把变量 foo 与特定的一块内存进行“绑定”，以便我们能通过变量名 foo 来引用存储空间。
    
-   它告诉 Scheme 被放进存储空间的初始值。
    

当你在其他语言中定义变量时，这三件事也会发生。在 Scheme 中，我们为三者都起了名字。

在图中，盒子体现了 Scheme 为变量分配存储空间的事实。在盒子旁的名字 foo 表示我们将存储空间命名为 foo。箭头表示盒子中的值是指向整数对象 5 的指针。（不要关心整数对象的实际表示方式，这一点都不重要。）

你也可以使用 define 来定义新过程：

```scheme
 (define (two-times x)
    (+ x x))
```

这里我们定义了名为 `two-times` 的新过程， 它接受一个参数 x。之后它调用加法过程 + 来使参数值与自己相加，并返回相加后的结果。

注意变量定义和过程定义之间的语法差异：对一个过程定义，名字两边有括号，参数跟在名字后面。

这和过程调用的方式很相似。考虑过程调用表达式 `(two-times 5)`，它返回 10；它和定义 `(two-times x)` 看起来很像，只是我们在形式参数 x 的地方使用了实际参数 5。

下面是一些你应该知道的编程语言术语：你传递给过程的参数有时被称为实参。位于过程之内的参数被称为形参 —— 它们代表任何在运行时实际传递给过程的内容。“实”意为你实际上传递给过程的内容，“形”意为你在过程内部调用的东西。通常我只说“参数”，但这和“实参”是同一个东西。有时我会讲到“参数变量”，这和“形参”是一样的。

你可以定义不带参数的过程，但你仍然需要在过程名两旁加上括号，以表明你在定义一个过程。当你调用它时，也在名字两旁加上括号，来表明这是一个过程调用。

例如，这是一个变量定义，它的值是 15：

```scheme
(define foo 15)
```

但下面这个是过程定义，它在被调用时返回 15：

```scheme
(define (foo) 15)
```

```
      +-------+
foo   |   *---|--->#<procedure>        
      +-------+
```

这张图展示了，当你定义过程时，你实际上定义了一个变量，它的值恰好是一个（指针指向的）过程。现在而言，你不必关心这个问题。需要知道的主要事情是，现在你可以通过名字 foo 来调用过程。例如，过程调用表达式 `(foo)` 会返回 15，因为该过程体做的就是返回 15 这个值。

通常，我们像这样缩进过程定义，过程内容在一个新的行，并缩进几个字符。

```
(define (foo)
   15)
```

这样可以更清楚地表明这是个过程定义。

<h2 id="2.1.4"> </h2>

##### 2.1.4.定义 vs 赋值

请注意，我们可以用两种方式赋给变量一个值：我们能在定义它时给它一个初始值，或者使用 `set!` 来改变它的值。

两者的区别在于 `define` 为变量分配存储空间，并为其命名。 `set!` 没有这样做。你必须在使用 `set!` 之前先定义一个供它作用的变量。

例如，如果没有定义变量 quux，表达式 `(set! quux 15)` 就是个错的，Scheme 就会抱怨。你请求 Scheme 将 15 （指针指向的）放到名为 quux 的存储空间中 —— 但 quux 并没有命名任何存储空间，所以这样做没有意义。

这就像是，我对你说：“把这个给 Philboyd”。然后给你一些东西，（比如，一支铅笔）。如果你不知道一个叫 Philboyd 的人，你可能会开始抱怨。`set!` 就是这样。我们必须在要求你为 Philboyd 做些什么之前，就“ Philboyd”是谁达成一致。`define` 是为标识符赋予意义的方式 —— 使它引用一块内存 —— 同时也给出存放的值。

<h2 id="2.1.5"> </h2>

##### 2.1.5.大多数运算符都是过程

在传统的的编程语言中，比如 C 和 Pascal ，过程调用和其他种类的表达式中有着尴尬的区分。例如，在 C 中，`(a + b)` 是一个表达式，但是 `foo (a, b)` 是一个过程调用。在 C 中，处理过程时，你不能用像 + 之类的运算符做同样的事。

在 Scheme 中，事情在词义和语法上要统一的多。大多数基础运算，比如加法，都是过程，并且有着书写表达式的统一语法 —— 被括起来的前缀表示法。因此，你在 Scheme 中写 `(+ a b)`，而不是 `(a + b)`。你会写 `(foo a b)`，而不是 `foo(a, b)`。不管是哪一个，它们都是带括号的，都是运算符后面跟着运算对象的。

对任何过程调用表达式（也叫组合），所有要传递的值会在实际调用过程之前计算。（这和 C 或 Pascal 没什么不同。）

<h2 id="2.1.6"> </h2>

##### 2.1.6.特殊形式

虽然大多数操作都是过程调用，但你还需要了解其他几种表达式，它们的行为是不同的。它们被称作特殊形式。

过程调用和特殊形式在语法上很相似 —— 它们都是括号中的语法单元，如 `(foo bar baz)`。然而，它们在语义上非常不同。这就是为什么你需要了解特殊形式，不把它们和过程搞混的原因。

如果左括号旁的第一个东西是表明特殊形式的关键字，如 `define` 或 `set!`， Scheme 会为这种表达式执行一些特殊的操作。如果不是，Scheme 会将括号中的表达式视为过程调用，并以通常的过程调用的方式对其进行求值。

（这也是为什么特殊形式被称作“特殊形式” —— Scheme 认为一些组合表达式需要做特殊处理，而不仅仅是进行过程调用。

你已经看到了 5 个或 6 个重要的特殊形式中的两个，`define` 和赋值运算符 `set!`。

注意，`set!` 并不是一个过程，因为它的第一个参数并不是一个以通常方式求值、并作为参数传递的值的表达式。它是存放值的地址。（例如，如果我们写 `(set! a b)` ，我们得到 b 的值，并将它放入名为 a 的存储空间中。）

同样，`define` 特别对待它的第一个参数 —— 变量名或过程名不是一个被求值并传递给 `define` 的表达式 —— 它只是个名称，你告诉 `define` 分配一些存储空间并使用这个名称。

我们将要看到的其他特殊形式包括：

-   控制结构：`if`，`cond`，`case` 与排序电路逻辑运算符（sort-circuiting logical operators）`and` 和 `or`
    
-   定义局部变量用到的形式：`let` 和它的变体 `letrec` 和 `let*`
    
-   循环结构：命名`let` 和 `go`
    
-   `quote` 和 `quasiquote`，它们让你在代码中将复杂的数据结构作为文本字面量（textual literals）来编写
    
-   `lambda`，用于以相当好用的方式创建新过程
    
也有一些非常特别的特殊形式，如 `define-syntax`，它允许你用“宏”定义你自己的特殊形式。

<h2 id="2.1.7"> </h2>

##### 2.1.7.控制结构是表达式

Scheme 的控制结构是表达式，并返回 值。if 表达式和 C 的 if-then 语句很像，但“then"分支和“else”分支也都是带返回值的表达式；if 表达式返回它求值的子表达式中的任何一个的值。

比如：

```scheme
(if (< a b)
    a
    b)
```

会返回变量 a 或变量 b 的值，这取决于谁小（如果相等，则返回 b 的值）。如果你熟悉 C 中的条件表达式，这就像是 (a < b) ? a : b。在 Scheme 中，不需要 if 语句和类似 if 的三元运算符表达式, 因为 if“语句”是表达式。

注意，即使每一个表达式都有值，也并不需要用到所有的值 —— 你可以忽略掉 if 表达式的值。`if` 特殊形式因此可被用于控制将要执行的内容，或用于返回一个值，或同时使用两者。这取决于你。

返回值设定的一致性意味着我们从来都不必显式使用返回语句，因此 Scheme 没有它们。假设我们想要写一个返回两个数中的最小值的函数 min，在 C 中，我们可能会这样写：

```C
int min(int a, int b)
{
    if (a < b)
        return a;
    else
        return b;
}
```

在 Scheme 中，我们可以这样做：

```scheme
(define (min a b)
   (if (< a b)
       a
       b))
```

不论取哪条分支，相应的变量（a 或 b)的值会被作为 if 分支的值返回，同时也是作为整个 if 表达式的值返回，这也作为过程调用的返回值。

当然，你也可以写不带 else 子句的单分支 if 。

```scheme
(if (some-test)
    (some-ation))
```

如果条件为假，单分支 if 的返回值是不确定的，如果你对返回值感兴趣，你应该使用两个分支的 if ，并显式确定两者应返回的东西。

注意到控制流是从上往下的，通过表达式的嵌套，if 控制着哪条子表达式被求值，这就像大多数语言中的控制语句的嵌套一样。值从表达式返回到调用方，就像大多数语言中表达式的嵌套。

你可以使用 `begin` 写出表达式的有序序列，例如：

```scheme
(begin (foo)
       (bar))
```

先调用 foo 再调用 bar。就控制流而言，(begin ... ) 表达式非常像 Pascal 中的 begin ... end 块，或 C 中的 { ... } 块。（我们不需要 end 关键字，因为括回做了相同的工作。）

然而，Scheme 的 `begin` 表达式并不仅仅是代码块，因为它们是带返回值的表达式。`begin` 返回序列中的最后一个表达式的值。例如，上面的 begin 表达式返回调用 bar 而返回的值。

过程也像 `begin` 一样运作。如果过程中包含几个表达式，它们会被顺序求值，而且最后一个表达式的值会作为过程调用的返回值。

下面是一个过程 baz，它调用 foo,，然后调用 bar 并返回对 bar 的调用的结果。

```scheme
(define (baz)
   (foo)    
   (bar))
```

<h2 id="2.2"> </h2>

#### 2.2布尔值

Scheme 提供了一个特殊的唯一对象，写作 #f，读作假。如果它是条件表达式 if（或 cond）的结果
，它会被算作假值。在大多数 Scheme 中，这是唯一会被作为假的值，所有其他的值都会被算作真。

假 这个对象和整数零不是同一个东西（在 C 中是这么认为的：0就是假），它和空指针也不一样（在 Lisp 中如此）。假 对象是个唯一的对象。

为了方便和清晰，Scheme 也提供了另一个布尔值，写作 #t，可以作为真值，注意，普遍意义上，值非假即真，但特殊的布尔对象 #t 在你想判断某事为真时很好用 —— 返回的布尔真值清楚地表明你返回了一个真值，而不是带有更多信息的其它值。

像其他对象一样，在概念上，布尔值是在堆上的，当你写下 #t 或 #f 时，它表示“一个指向规范真值的指针”和“一个指向假值对象的指针”。

Scheme 提供了一些过程和特殊形式来操作布尔值。过程 `not` 作为 非 运算符，总是返回真与假（#t 或 #f），如果作用于 #f，它就返回 #t。因为所有其他值都算作 真，将 not 作用于其他任何东西都会返回 #f。

<h2 id="2.3"> </h2>

#### 2.3.其他控制流结构

我们已经看到，特殊形式 `if` 是一种表达式，它在影响控制流的同时返回值。Scheme 还有使用更广泛的条件结构 `cond`，和扩展逻辑运算符 `and` 和 `or`。它们都是带返回值的表达式；它们也都是特殊形式，而不是过程：它们依据其他表达式的返回值，来判断表达式是否被求值。

-   [cond](#2.3.1)：`cond` 就像 if...else if....else....
    
-   [and 和 or](#2.3.2) ：`and` 和 `or` 是“短路的”（short-circuiting）
    

<h2 id="2.3.1"> </h2>

##### cond

在大多数过程式语言中，你可以使用 if 的扩展版本写出一列 if 测试，就像这样：

```
if test then
    action();
else if test2 then
    action2();
else if test3 then
    action3();
else
    action4();
```

Scheme 有一个相似的结构，一个叫做 cond 的特殊形式。上面的例子在 Scheme 中可以被写成这样：

```scheme
(cond (test1
       (action1))
      (test2
       (action2))
      (test3
       (action3))
      (else
       (action4)))
```

注意，每一对 test-action 都在同一对括号中。在这个例子中，test1 只是个变量引用，而不是过程调用，我们测试变量 test1 ，来判断它的值是否为 #f；如果不是，我们执行 (action1)，也就是调用过程 action1。如果它是，则控制“下落”到下一个测试，并继续这样的操作，直到某一个测试值为真值（除 #f 之外的值）。

我们将相应于测试部分的执行部分缩进了一个字符。这样，操作会直接放在测试的下面，而不是放在将它们组合在一起的开括号下。

我们不需要 else 子句，因为我们可以使用求值总为真值的测试表达式来达到相同的效果。这样做的一种方法是使用字面量 #t，布尔真值，因为它总为真。

```scheme
(cond (test1
       (action1))
      (test2
       (action2))
      (test3
       (action3))
      (#t              ;字面量 #t 总为真，所以
       (action4)))    ;如果到了这里，这个分支会被执行
```

上面的代码和下面的 if 嵌套表达式等价：

```
(if test1
    (action1)
    (if test2
        (action2)
        (if test3
            (action3)
            (if #t
                (action4)))))
```

像 `if` 一样，`cond` 返回被求值的分支的值。例如，如果 test1 为真，上面的 `cond` 表达式会返回过程调用(action1)的返回值。

记住，每一条 `if` 分支都是单个表达式；如果你想要在一条分支中执行多个表达式，你必须将表达式包在 `begin` 中。有了 `cond`，你就不必这么做了。你可以在测试表达式后面附加多条执行表达式，Scheme 会对所有表达式按顺序求值，并返回最后一个表达式的值。就像个 `begin` 表达式或过程。

假设我们想要调整上面的 cond 例子以便它打印出它选择的分支，同时对表达式求值并返回表达式的值，我们可以这样做：

```scheme
(cond (test1
       (display "taking first branch")
       (action1))
      (test2
       (display "taking second branch")
       (action2))
      (test3
       (display "taking third branch")
       (action3))
      (else
       (display "taking fourth (default) branch")
       (action4)))
```

这个 `cond` 表达式会返回和之前的 `cond` 表达式相同的值，因为它总会返回分支的最后表达式的值。然而，它在执行时，它会显示它执行的操作。我们可以在以求值和显示效果为目的时使用 `cond`。

要特别小心 `cond` 的括号。你必须把一条分支的测试表达式和相应的一系列执行表达式放入同一个括号中。如果你想在这些表达式中进行过程调用，你必须将过程调用放入括号中。在上面的例子中，如果我们想要将第一个测试写成对过程 test1 的调用，而不是获得变量 test1 的值，我们会这样写：

```scheme
(cond ((test1)
       (display "taking first branch")
       (action1))
      ...)
```

而不是

```scheme
(cond (test1
       (display "taking first branch")
       (action1))
      ...)
```

（注意到这儿的缩进。我们通常在垂直方向上排列测试部分和相应的执行序列，不论表达式是否以括号开头。也就是说，我们在包含它们的括号的开括号的下面缩进一个字符。）

“额外的”括号是必须的，以便 `cond` 能分辨执行序列是和哪个测试组合在一起的。

不要怕在只有一或两条分时使用 `cond`，`cond` 通常用起来比 `if` 更舒服，因为它能够执行一系列表达式，而不只是一条。看见像下面的样式是很寻常的：

```scheme
...
(cond ((foo)
       (bar)
       (baz)))
...
```

不要被它搞糊涂了 —— 它是只有一条分支的 cond 表达式，就像单分支 if 一样。我们可以这样写：

```scheme
...
(if (foo)
    (begin (bar)
           (baz)))
...
```

使用 `cond` 更方便，这样我们就可以在调用 baz 并返回其值前先调用 bar，而不用显示使用 `begin` 表达式来使其顺序求值。

我们说 `cond` 是分支带有 `begin` 的 `if` 的语法糖。没有我们只能用 `cond` 做，而不能直接用 `if` 和 `begin` 做的事 —— `cond` 只是给了我们“加糖的”语法，也就是用起来更舒服。

大部分 Scheme 特殊形式就像这样 —— 它们只是写起来更加舒服的方式罢了，你能用更基础的特殊形式将它们表示出来。（在特殊形式中，只有五个“核心”特殊形式是必须的，其他的都和这些核心特殊形式的组合等价。）

<h2 id="2.3.2"> </h2>

##### 2.3.2. and 和 or

特殊形式 `and` 和 `or` 能被作为逻辑运算符使用，但它们也可被作为控制结构，这也是为什么它们是特殊形式。

`and` 接受任意数量的表达式，并对它们进行顺序求值，直到其中之一返回 #f 或它们全被求值为止。当某个表达式返回 #f，`and` 将 #f 作为 `and` 表达式的返回值返回。如果没有表达式返回 #f，它会返回最后一个子表达式的值。

这确实是一个控制结构，而不仅仅是一个逻辑运算符，因为子表达式是否被求值取决于之前的子表达式的返回值。

`and` 通常既用于控制流，又用于求返回值，就像一个 `if` 测试序列。你可以写出这样的东西

```
(and (try-first-thing)
     (try-second-thing)
     (try-third-thing))
```

如果三者都返回真值，`and` 会返回最后一个表达式的值。然而，如果其中之一返回 #f ，剩余的表达式不会被求值，#f 会作为全部表达式的返回值。

同样，`or` 接受任意数量的参数，返回第一个返回值为真值（不是 #f 的任何值）的表达式的值。当它得到一个真值时，它会停止对剩余表达式的求值，并返回那个真值。

```
(or (try-first-thing)
    (try-second-thing)
    (try-third-thing))
```

`or` 在它所求值的子表达式为真之前会持续对子表达式求值；如果遇到了真值，`or` 会返回这个值。如果全部表达式都返回 #f，`or` 会返回 #f。

##### not 只是个过程

`not` 是接受单个参数的过程，并返回 #t 或 #f，这个参数可以是任意类型的 Scheme 值。如果参数值为 #f（唯一的假值对象），它会返回 #t，否则返回 #f。也就是说，所有的值，除了假值对象，都被算作真值 —— 就像在条件表达式中一样。例如，(not 0)返回 #f。

考虑到 `and` 和 `or` 都是 特殊形式，你可能会认为 `not` 逻辑运算符也是个特殊形式。它不是。它只是个过程 —— 特别地，一个谓词。

这是有道理的，因为 `not` 总是对它的（一个）参数求值并返回一个值。它并未特殊对待任何参数 —— 它就是个普通的一等对象，在过程调用之前，参数以普通的方式被求值。

普遍意义上说，能作为过程的运算符都是过程。Scheme 只认为真正特殊的东西是特殊形式，在过程调用中，需要对它们的参数进行特殊处理。（即使是 Scheme 中最为强大的控制结构，`call-with-current-coutinuation`，也只是个一等过程。）

==========================================================================

这是 Hunk A 的结尾

是时候去试一试了

这时，你应该去看下一章的 Hunk B 并使用 Scheme 系统来试一试例子。然后回来，继续这一章。

==========================================================================

<h2 id="2.4"> </h2>

#### 2.4.注释

==========================================================================

Hunk C 从这里开始：

==========================================================================

[ 我是不是应该早点讲这个，并把它用在例子中呢？]

你可以，也应该把注释放到你的 Scheme 程序中。注释从一个分号开始。Scheme 会忽略这一行分号之后的所有内容（这就像是 C++ 中的 // 注释。）

例如，下面是一个带有注释的变量定义：

```scheme
(define foo 22) ; 定义一个初始值为 22 的变量)
```

当然，大多数注释应该要能告诉你一些代码中不明显的事情。

标准 Scheme 没有像 C 一样的 /* ... */ 块注释。

用两到三个分号，而不是一个来开始一条注释是很寻常的。这让注释的开始比单个分号显得更加突出。额外的分号会和所有在同一行的其他字符一起被忽略。

对大多数注释使用两个分号是寻常的形式，对占据一整行，或描述文件内容的注释，使用三个分号。

<h2 id="2.5"> </h2>

#### 2.5.括号和缩进

学习 Scheme 最大的两个障碍可能就是括号和缩进了。在 Scheme 中，括号的使用方式和大多数编程语言中略有不同。缩进也很重要，因为语言的表面语法是如此规则。当阅读 Scheme 代码时，有经验的程序员阅读缩进结构和记号一样多。如果你没有正确地使用括号，你的程序不会正确地运行。如果你没有正确地使用缩进，它们会很难理解。

Scheme 的语法，与看第一眼时的（奇怪）印象相比，其实和 C 或 Pascal 的语法更相似。毕竟，几乎所有的语言都是以嵌套的（语句或）表达式为基础。像 C 或 Pacsal 一样，Scheme 形式自由，你可以按你的任意想法进行缩进。

有些人编写 Scheme 代码时使用与 C 相似的缩进，将闭括号放在开括号的正下方，来显示嵌套。（就像我在后面解释的，这样做的人通常是不会恰当使用编辑器的初学者。）他们可能会这样写

```scheme
;;糟糕的 if 表达式缩进
(if a
    (if b
        c
        d
    )
    e
)
```

而不是像这样

```scheme
;;好的 if 表达式嵌套
(if a
    (if b
        c
        d)
    e)
```

第一个版本看起来有点像 C，但它并不真正易读。第二个例子清晰地向你展现了它的结构，如果你知道如何阅读 Scheme 的话。实际上它更易读，因为它并不都是拉长的。第二个例子使用了更少的页面或电脑屏幕的空间。（在一个窗口编辑代码，同时在其他窗口做其他的事情时，这是很重要的 —— 你在一个时间可以看见更多程序。）

有两件与 Scheme 括号有关的事情需要牢记。第一，括号是重要的。在 C 或 Pascal中，你通常可以省略括号，因为运算符优先级分析，编辑器会弄清分组。更重要的是，你可以在表达式两旁加上额外的括号而不影响表达式的意思。

在 Scheme 中，这样可不行！在 Scheme 中，括号的作用不只是让运算符之间的关系清晰。在 Scheme 中，括号不是个可选项，在一个东西的两旁放上额外的括号会改变它的意思。例如，表达式 foo 是一个变量引用，它的作用是取得变量 foo 的值，另一方面，表达式 (foo) 是对无参数过程 foo 的调用。

（注意到，即使是在 C 中，使用太少或太多括号来编写过程调用通常是不可接受的：调用 foo(a,b) 不能被写成 foo a,b 或 foo((a,b))。）

大体上，你必须知道什么时候需要用括号，什么时候不用，这需要对于 Scheme 规则的理解。有些括号表明过程调用，而有些仅仅是作为特殊形式的间隔符。幸运的是，规则很简单；它们应该会在下面一到两个章节中变得非常清楚。

你需要知道的另外一件事是它们必须配对。对每一个开括号，必须有一个闭括号，当然，闭括号必须在正确的位置。

##### 2.5.1.[让你的编辑器帮你](#2.5.1)：编辑器使括号配对变得简单

##### 2.5.2.[缩进简单的东西](#2.5.2)：过程调用和简单的控制结构

##### 2.5.3.[cond 的缩进](#2.5.3)：没用恰当的缩进，cond 是不可读的

##### 2.5.4.[缩进过程定义](#2.5.4)

<h2 id="2.5.1"> </h2>

##### 2.5.1.让你的编辑器帮你

如果你有个像样的编辑器，括号配对是很简单的。例如，在 vi 中，你可以把光标放在一个括号上，按下 %，它会向前或向后扫描（分别根据是开括号还是闭括号）来寻找配对的括号并使其发光，它会跳过任何配对的括号；如果没有找到配对的括号，它会警告你。

大多数编辑器都有像这样的功能。学习使用它。通常很容易把闭括号弄对，如果你心存疑虑，可以使用编辑器来确保你在正确的地方用到闭括号。

一些编辑器，像 Emacs，有专门编辑 Lisp 和 Scheme 的 Mode。这当然很有用，但只有配对括号的功能是一个编辑 Scheme 的编辑器所必须的。Emacs Scheme 的一个好处是，如果你愿意，它会自动对你的代码进行缩进，这会告诉你，你的表达式是否是按照它所期望的方式嵌套的 —— 如果你的括号不对，文本看起来会很滑稽，并提示你改掉错误。

（cnuscheme 是 Emacs 对 Scheme 的一个Mode，可以从通常的 Emacs 模组代码中得到。它只是个 Emacs Lisp 程序，通过定制来使 Emacs“理解”Scheme 的语法并帮助你格式化你的代码。使用 Emacs Lisp 包 cmscheme.el，它会提供给你一个方便的 Scheme 编辑模组。它可以从 Scheme 仓库中获得。）

即便没有一个特殊的包，一个编辑器也可以帮你不少。例如，大多数 Emace 模组自动配对括号，在你输入相应的闭括号时闪一下开括号。用一点时间弄清你的编辑器的括号配对功能会节省你很多时间。

#|注：emacs 自带 scheme-mode，会自动缩进代码。可以安装 paredit-mode 来提高体验，emacs才是 scheme 的 IDE，—— 身为Emacs党的我自豪的断言道 :p |#

<h2 id="2.5.2"> </h2>

##### 2.5.2.缩进简单的东西

#| ~the original website is empty......~ |#

<h2 id="2.5.3"> </h2>

##### 2.5.3. cond 的缩进

小心对待和 `cond` 有关的括号和缩进。注意，在 test-action 子句中，只缩进一个字符，但这是很重要的。没有这个缩进，`cond` 读起来会很困难。

假设我们用 `cond` 替换下面尴尬的 `if` 表达式。

```scheme
;;需要 begin 来顺序执行分支的尴尬的 if 表达式
(if (a)
    (begin (b)
           (c))
    (begin (e)
           (f)))
```

我们可以写成这样：

```scheme
(cond ((a)
       (b)
       (c))
      (else
       (e)
       (f)))
```

有时，当一个 `cond` 的子句很小时，一个完整的子句会被水平地写出来。上面的实例很可能会被写成这样：

```scheme
(cond ((a) (b) (c))
      (else (d) (e)))
```

同样也要小心对待条件表达式两旁的括号。注意,a 的两边之所以有括号，是因为它是个对无参数过程的调用，而不是因为你总是在条件表达式的两边加括号。（注意到，#t 的两边没有括号，如果我们只是想测试变量 a 的值，而不是调用它并测试它的结果，a 的两边不会有括号。)

<h2 id="2.5.4"> </h2>

##### 2.5.4.缩进过程定义

就像我在前面提到的，过程定义的缩进有着特殊的规则。你一般要将过程的内容缩进一些字符长度（我缩进 3 个），但是，不要把过程内容的表达式直接放在变量名列表下。

不要这样做：

```scheme
(define (double x)
        (+ x x))
```

如果你这样做，一个过程定义看起来就像是个过程调用，或是个普通的变量定义。要让定义一个过程显得明显，这样做：

```scheme
  (define (double x)
     (+ x x))
```

这样就清楚表明 (double x) 和 (+ x x) 不是一类东西。前者声明了怎样调用过程，后者说明了过程会做什么。

<h2 id="2.6"> </h2>

#### 2.6.值皆指针

就像我前面说的，所有的值在概念上都是指针指向的，堆上的对象，并且你不能显式释放内存。

说到“对象”，我不一定是指面向对象意义上的对象。我只是指像是 Pascal 的记录或是 C 的结构一样的数据对象，它们能够通过指针引用（也许不能），能够承载状态信息。

一些版本的 Scheme 有面向对象的对象系统。（这也包括我们的 RScheme 系统，其中标准 Scheme 类型都是统一对象系统中的所有类。）然而，在这本书中，我们会以更宽广的含义使用“对象”这个词，意思是一个可以指向的实体。

##### 2.6.1.[所有的值都是指针](#2.6.1)：All Value are Pointers

##### 2.6.2.[堆上的对象](#2.6.2)：Object on the heap

<h2 id="2.6.1"> </h2>

##### 2.6.1.所有的值都是指针

概念上，所有的 Scheme 对象都在堆上分配，并通过指针引用。这确实让事情变得简单，因为你不必担心在当你需要使用值的时候，需要对指针解引用 —— 你总是这样做。因为指针的解引用是普遍的，过程总是在真正需要用到值时，对指向值的指针解引用，你不必显示解引用。

例如，前置定义的 Scheme 过程 `+` 接受两个指向数字的指针，自动在做加法之前对两个指针解引用。它返回一个指向相加值的指针。

所以，当我们对表达式 `(+ 2 3)` 求值来计算二加三，我们会接受一个指向 2 的指针和一个指向 3 的指针，并将这些作为参数，传递给过程 `+`。`+` 会返回一个指向 5 的指针。我们可以嵌套表达式，例如，(* (+ 2 3 ) 6)，这样指向 5 的指针转而被传递给过程 `*` ，因为这些函数都接受指针作为参数，并将指针作为返回值，你可以忽略指针，像在其他任何语言中一样写下算术表达式。

当你思考它的时候，在数学意义上，改变整数的值是没有任何意义的。例如，把整数 6 的值变成 7 有什么意义？这并不合理，当然如此。6 是唯一的，抽象的数学对象并没有任何能被改变的状态 —— 6 就是 6，它的举止永远是 6。

在传统语言中，并没有真正改变一个整数值 —— 它将一个整数值（的拷贝）替换为另一个整数值（的拷贝）。这是因为，大多数编程语言既有指针语义（对指针变量）又有值语义（对非指针变量，如整数）。你创建多个值的拷贝，在之后的赋值中将拷贝值破坏。

在 Scheme 中，我们不必破坏整数的值，因为我们通过用一个指针代替另一个达到了效果。一个整数在 Scheme 中是个唯一的实体（概念上），就像它在数学中一样。我们并没有多次拷贝一个特定的数，只是多次引用。（实际上，Scheme 处理数字并不真的这么简单和美妙，由于我将在不久之后解释的效率问题。）

我们将在之后看到，如果没有影响到程序员对事物的看法，一个实现可以自由地对这些指针进行优化，但当你尝试理解一个程序，你总是需要将值视为指向对象的指针。

指针的普遍使用使很多事情变得简单。在 C 或 Pascal 中，无论你是处理一个原始值或一个指针，你必须小心。如果你有一个指针并且你需要知道实际的值，你必须显式对指针解引用（例如，C中的前缀运算符 `*` ，或 Pascal 中的前缀运算符 `^`）。如果你有一个值而且你需要用指针指向它，你必须得到它的地址（例如，C 中的前缀运算符 `&`，或 Pascal 中的前缀运算符 `^`）

在 Scheme 中，这些麻烦都是不必要的。用户定义的程序一致地传递指针，当他们深入到预定义的程序时（如内置的 `+` 过程或 `set!` 特殊形式），这些底层内置操作会执行任何必要的解引用。

（当然，当做比如遍历链表的事情时，程序员必须要求对指针解引用，但从程序员的角度来看，这只是意味着从已指向的对象的内容中获得另一个指针值。）

有时，据说，像 Scheme 这样的的语言（Lisp，smalltalk，Eiffel 和 Java）“没有指针”。至少可以说，相反的观点是真实的 —— 一切皆指针。它们所没有的，是你所关心的对指针和非指针的区分。

##### 多数实现优化了许多指针

你可能认为，对每一个对象都用一个指针来指向的话，开销会很大，因为你不得不为指针和指针指向的对象都分配空间，同时你也不得不使用额外的指令来通过指针访问值。

“一切都是指针”是在语言层面 —— 例如，从程序员的角度。但一个 Scheme 系统实际上并不必像语言层面上那样来表示事物。

许多 Scheme 实现都优化了许多指针。例如，将整数值表示为用指针指向的堆上的对象的做法是低效的。Scheme 实现因此使用一些技巧，不通过真正使用指针来表示整数。（再次提醒，记住，这只是对程序员隐藏的实现技巧，整数值具有指针的语义，即使它们的表示方式与其他东西不同。）

相比于把整数值放在堆中，然后传递指针给它们，大多数实现把实际的整数的位组合（bit pattern）直接放进变量中 —— 毕竟，合理大小的整数适合机器字长。

存储在变量中的短值（short value）（如普通整数）称为直接值，不是用于间接引用对象的指针。

将整数和短值放到变量中的问题是 Scheme 不得不对它们进行区分，并将可能具有相位组合的指针和它们区分开。

解决方案是标记（tagging）。每个变量中的值实际上有一些位被用作类型标记，这样就说明了变量的类型 —— 例如，是否为指针。使用一些位作为标记略微减少了可用于实际值的存储空间，但就像我们将要看到的，这通常不是个问题。

似乎直接存储整数的位组合会产生打破 Scheme 所要展现的抽象 —— 幻想所有值都是指向堆上对象的指针。然而，并非如此，因为语言的强制限制，使程序员看不见其间的差异。

就数字（数学上的）和一些其他类型而言，你不能改变对象本身的状态。没有通过对整数使用副作用，使它表现得不同于它本身的性质的方法。我们说，整数是不可变的，也就是说，你不能使它变异（mutate）（改变）。

如果整数实际上分配在堆上并通过指针引用，而且如果你能够改变整数的值，那么该更改对于其他指向整数的指针是可见的。

（这并不是说变量的值不能一会儿是一个整数，一会儿又是另一个 —— 变量的值实际上是指向整数的指针，不是整数本身，而且你真的只是将指向一个数的指针，替换成了指向另一个数的指针。）

<h2 id="2.6.2"> </h2>

##### 2.6.2.堆上的对象

大多数 Scheme 对象只有通用的值单元格字段 —— 任何字段都能储存任何 Scheme 值，无论是带标记的直接值还是带标记的指向堆分配对象的指针。（当然，概念上它们都是指针，所以字段的类型只是（“可以指向任何东西的指针”。）

例如，一个序对(pair)（在 Lisp 术语中被称为“ cons 单元格”)是堆上的带两个字段的对象。每个字段都能存储任意种类的值，比如数字，文本字符，布尔值，或是指向其他堆上对象的指针。

序对的前一个字段被称为 car 字段，第二个字段被称为 cdr 字段。这些名词是所有计算机科学名词中最蠢的。（它们只是第一个 Lisp 实现及其运行的计算机上的历史产物。）

序对可以通过调用过程 `cons` 来创建。例如，要创造一个 car 字段值为 22，cdr 字段值为 15 的序对。你可以写下过程调用 (cons 22 15)。

序对的字段就像变量绑定，这样它们可以存储任何类型的 Scheme 值。绑定和字段都被称为值单元格 —— 也就是说，它们是可以存放任何类型值的位置。

在大多数实现中，每个堆上分配的对象都有一个隐藏的“头”字段，那是作为 Scheme 程序员的你所不必知道的。额外的字段存储了类型信息，清楚地表明堆上分配的对象的种类。所以，放在内存中，序对看起来就像这样：

```
       +-----------+
header | <PAIR-ID> |         
       +===========+
   car |     +-----+----->22
       +-----------+
   cdr |     +-----|----->15
       +-----------+
```

在这张图中，对（cons 单元格）中的 car 字段存储整数 22，cdr 字段存储整数 15。

存储在序对中的字段的值画成了箭头，因为它们是指向数字 22 和 15 的指针。

（实际表示这些值的方式可能是 2 位用作区分整数和真正的指针的标记，30 位用作存储数字二进制数，但你不必担心这个。）

Scheme 提供了内置过程 `car` 来取得一个序对的 car 字段的值，还有 `set-car!` 来设置这个字段的值。同样还有 `cdr` 和 `set-car!` 用来取得和设置 cdr 字段的值。

假设我们有个对变量 foo 的顶级（top-level）变量绑定，它的值是指向序对的指针。我们可以像这样把这种情况画出来：

```scheme
                             +=========+
    +---------+        header|  <PAIR> |
foo |    *----|------------->+=========+
    +---------+           car|    *----+---->22
                             +---------+
                          cdr|    *----+---->15
                             +---------+
```

大多数 Scheme 对象都是以相似的方式表示的。例如，一个向量（一维数组）通常表示为线性的值单元的数组，它可以存储任何类型的值。

即便实际上不是这样表示的对象也可以用这种方式思考，因为在概念上，堆上的所有东西都能通过指针引用。

<h2 id="2.7"> </h2>

#### 2.7.自动内存管理

在像 C 或 Pascal 的语言中，数据对象可以通过几种方式分配。（回忆一下，谈到“对象”我只是指像记录（records）的数据对象。）它们可以被静态地分配（像是全局变量的情况），或使用像是 malloc 或 new 的分配函数，在程序运行时进行堆上的动态分配。

Scheme 更简单 —— 所有的对象都在堆上分配，通过指针引用。Scheme 的堆是垃圾回收的，这意味着 Scheme 系统会在你之后自动清理内存。时不时地，系统会找出不再使用的对象，并回收它们的存储空间。（这种方式是非常保守和安全的 —— 收集器不会回收你的程序中指针指向的对象，也不会通过任何可能的指针遍历来接触到对象。不要害怕收集器会在你没有注意时，吃掉你还在关注的对象！）

垃圾回收的使用支持了不定程度（indefinite extent）的抽象。这意味这对象在概念上是永久存活的，或至少是在它们和程序有关时 —— 没有重用内存的概念（在语言层面）。以这个视角看待运行的程序，内存就是无限的 —— 它能够无限地分配内存，而不需要重用它们的空间。

当然，这个抽象，当没有足够的内存供你做你尝试做的事情时，就失效了。如果你尝试创建一个比可用内存更大的数据结构，你的内存会用光。垃圾回收并不能给你提供你没有的内存。

一些人认为垃圾回收在时间或空间上的开销很大。即便垃圾回收不是毫无代价的，它的代价也比通常认为的要小很多。一些人也有着在关键时刻因为垃圾回收而使得系统停止的糟糕经历，但现代的 GC 技术能够解决这个问题。（如果你对高效而无中断的垃圾回收实现感兴趣的话，我的 GC 研究论文是个不错的起点，可以访问我的研究小组网站（ http://www.cs.utexas.edu/users/oops 。）

<h2 id="2.8"> </h2>

#### 2.8.动态类型

##### 对象具有类型，但变量没有

如果我把手指当作指针，我可以用它指向任何东西 —— 一台电脑，一幅画，一辆摩托车，或是任意数量的东西。Scheme 中的变量就像是这样。

在 Scheme 中，所有的变量都具有相同的类型：“可以指向任何东西的指针”

Scheme 是动态类型的，这意味着变量没有固定的类型，但对象具有。一个对象自带类型 —— 整数永远都是整数，但一个变量有时可能引用一个整数，有时又是个字符串（或其他东西）。语言提供运行时的类型检查，来确保你不会对对象执行错误的操作 —— 例如，如果你尝试将两个字符串相加，系统会发现这个错误并提示你。

有时，人们认为像 Scheme（还有 Lisp，Smalltalk）这样的语言是无类型的。这非常具有误导性，在真正的无类型语言（比如 FORTH 和大部分汇编语言）中，你可以按照你想要的方式来解释一个值 —— 作为一个整数，一个指针，或任何其他东西。（你在 C 中也可以这么做，使用不安全的强制转换，这是许多耗时的 bug 的来源。）

在动态类型系统中，类型在运行时确定。例如，如果你尝试使用作用于数字的过程 `+` 来把两个表相加，系统会发现这个错误并从容地停止 —— 它不会傻乎乎地认为你知道你在做什么。你也不能将非指针值错误解释为一个指针，产生让你的程序崩溃的，致命的分割违规。

你可能认为动态类型成本很高，它确实如此。但好的 Scheme 编译器能够通过编译时的类型推断来消除大部分开销，大部分高级实现还允许在性能关键位置进行类型声明，以便编译器生成类似于 C 或 Pascal 的代码。

==========================================================================

这是 Hunk C 的结尾

是时候试一试了

在这个时候，你应该去读一读下一章的 Hunk D 并使用 Scheme 系统来试一试例子。然后回来，继续这一章。

==========================================================================

<h2 id="2.9"> </h2>

#### 2.9.空表

==========================================================================

Hunk E 从这儿开始：

==========================================================================

在 Scheme 中，只有一个空指针值，叫做“空表”，打印为 ()。（之后，我们会看到它为什么会这样写，还有为什么它会被称为“空表”。）

概念上，空表是个特殊对象，一个“空”指针是一个指向表的结尾对象的指针。你可以忽略这个事实并仅仅将它看作一个空指针，因为你不能对它所指向的对象做什么有趣的事。

（在有些实现中，空表对象 '() 是个真正的可用指针引用的对象，而且空指针真的的是指向它的指针。在其他实现中，一个空表是个不可更改的值，是空指针的特殊标识。在 Scheme 语言的水平上，在特定 Scheme 系统中使用哪种方式来实现并不重要。你所真正能对空指针做的是将它与其他的指针比较，来判断它们是否也是空指针。）

空表对象扮演着用作任何目的的空指针。Scheme 只有一种指针（可以指向任意内容的指针），所以只有一种空指针（指向空内容的指针）。

Scheme 提供了一个过程，null? 来检查某个值（指针指向的）是不是空表，也就是说，是否为一个空指针。例如，如果变量 foo 是个空表，(null? foo) 会返回 #t，否则返回 #f。

你可以将空表在你的程序中写作字面量 '()。也就是说，表达式 '() 返回空表（空指针）。之后我会解释，当你写下空表作为字面量时，为什么你必须在一对空的括号之前使用单引号标记。

<h2 id="3"> </h2>

### 3. 序对和表

像 Lisp 一样，Scheme 有着处理一种特别灵活的表——由序对组成的表，的内置过程。它的 cdr 字段存储着将它们连在一起的指针，它的 car 字段存储值。

#### 3.1. [cdr 连接的表](#3.1)：空表作为结尾的，由 cdr 连起来的，由序对组成的表，car 字段存储对物体的引用。

#### 3.2.[表和引用](#3.2)：字面量表

#### 3.3.[空表这个名字哪来的](#3.3)：为什么它会被这么叫，会被打印为 ()，并会被作为字面量而写作 '()。

#### 3.4.[一些方便的表处理过程](#3.4)：length，list，append 和 reverse

<h2 id="3.1"> </h2>
    
#### 3.1.cdr 连接的表

在 Lisp 和 Scheme 中，你不必像传统方式一样，通过指向下一个对象的“next”指针来将对象们串成表。你可以创建一个由序对组成的表，其中，序对的 cdr 字段存储指向对象的指针，并将序对连接成一串。

这并不是 Scheme 中真正的表数据类型。一个表时实际上是由以空指针结尾的序对序列组成的。一个空指针也是一个表 —— 它是没有序对的以空指针结尾的表。我们有时会谈到“表的 car 部分”和“表的 cdr 部分”，但它们真正的意思是“表的第一个序对的 cdr 部分”和“表的第一个序对的 cdr 部分”。

假设我们有着指向一个含有整数 22，15 和 6 的表的变量 foo。下面是画出这种情况的一种方法。

```scheme
                   +---------+          +---------+         +---------+
    +---------+    | <PAIR>  |          |  <PAIR> |         |  <PAIR> |
foo |    *----+--->+=========+      +-->+=========+     +-->+=========+
    +---------+    |       22|     /    |       15|    /    |        6|
                   +---------+    /     +---------+   /     +---------+
                   |    *----+---+      |    *----+-->      |    *    |
                   +---------+          +---------+         +---------+
```

这样展现了与实际上的内存真正代表的很相近的东西。但还有更好的画出表的方法，这种方法强调了数字的值在概念上是指针指向的数，并与我们通常对表的看法相对应：

```scheme
    +---+    +---+---+      +---+---+      +---+---+
bar | *-+--->| * | *-+----->| * | *-|----->| * | * |
    +---+    +-+-+---+      +-+-+---+      +-+-+---+
               |              |              |
              \|/            \|/            \|/
              22             15              6
```

我省略掉了对 Scheme 程序员不可见的，对象的头字段。

我使用了特殊方法来绘制序对，让 car 字段和 cdr 字段边靠边。将字段靠在一起使我能够从左到右地画出表，让 cdr 字段在合适的位置来表现出它作为“next”指针的用途。我把整数画在序对的外面，用 car 字段中的指针指向它们，因为这就是语言层面的看法。

这样强调了表和在表“里面的”东西实际上是分开的。

我们省略了序对头，因为它们只是底层细节，因为它们可能是因系统而异的隐藏实现细节，也因为 Scheme 程序员能认出这种“两盒式”的点对描绘。

Scheme 表结构的一个主要优点是，你不必修改一个对象来将它放入表中 —— 一个对象能同时在多个表中，因为一个表是一串带有指向表中内容的指针的序对。这与人们在大多入门编程课堂上，被以传统方式教导创建单链表相比，要清晰的多。（在语言中，所有的值都是指针这一点是非常自然的 —— 当然，由对象组成的表真的只是由指向对象的指针组成的表。）

例如，你可以有含有相同元素的两个表，或是其中一些元素相同，但很可能顺序不同的表。

```scheme
    +---+    +---+---+      +---+---+      +---+---+
bar | *-+--->| * | *-+----->| * | * +----->| * | * |
    +---+    +-+-+---+      +-+-+---+      +-+-+---+
               |              |              |
              \|/            \|/            \|/
              22             15              6
              /|\                           /|\
               |                             |
    +---+    +-|-+---+                     +-+-+---+
baz | *-+--->| * | *-+-------------------->| * | * |
    +---+    +---+---+                     +---+---+
```

这儿我画了两个表，bar 和 baz  ——也就是说，两个表是变量 bar 和 baz 的值。bar 带有元素 22，15，和 6，baz 只带有元素 22 和 6。

由于这两个表都只是由序对构成的，所以它们是不同的序对，我们可以在不修改其中一个的情况下修改另一个，而且也不需要修改在表“里面”的对象。例如，我们可以让一个表反序而不影响另一个。

（我们也不必创建一个特殊的，带有两个 next 字段的表节点，以便一个东西同时能在两个表中。我们可以使用两个，三个或四个分开的序对表。）

Scheme 有书写表的文本表达的标准方式。考虑上图所示情况，对表达式 `(display bar)` 求值会打印 (22 15 6)。对表达式 `(display baz)` 求值会打印 (22 6)。注意到，Scheme 只是在括号中写出了表中的物体 —— 它不代表单个的序对，而只是 car 部分的值。

动态类型也有助于表的有用性。序对表能存储任意类型的对象，甚至是混有不同类型对象的包。因此，例如，序对表可以是整数表，可以是由表组成的表，或是任何我们还没碰到过的类型的对象组成的表。它也能是个混有整数、其他的表、或类似东西的表。因此，一些表处理函数在一系列情况中很有用 —— 例如，单链表查找函数能够在任意种类的表中查找靶向对象。

下面这张图展示了对变量 bar 和 foo 的变量绑定。bar 的绑定存有表 (10 15 6)，foo 的绑定存有表 (22 15 6)。我们说这些表共享了结构，也就是说，一个表的部分也是另一个表的一部分。

```scheme
                   +---------+
    +---------+    | <PAIR>  |
bar |    *----+--->+=========+
    +---------+    |       10|
                   +---------+
                   |    *----+-+
                   +---------+  \
                                 \
                   +---------+    \      +---------+        +---------+
    +---------+    | <PAIR>  |     \     | <PAIR>  |        | <PAIR>  |
foo |    *----+    +=========+       +-->+=========+    +-->+---------+
    +---------+    |       22|      /    |       15|   /    |        6|
                   +---------+     /     +---------+  /     +---------+
                   |    *----+---+       |    *----|-+      |    *    |
                   +---------+           +---------+        +---------+
```

这张图可能会很好的与内存中的真实表示相对应，但还是有点令人困惑。

更加普遍的绘制方式是这样的

```scheme
    +---+    +---+---+
bar | *-+--->| * | *-+------+
    +---+    +-+-+---+      |
               |            |
              \|/           |
              10            |
                           \|/
    +---+    +---+---+      +---+---+      +---+---+
foo | *-+--->| * | *-+----->| * | *-+----->| * | * |
    +---+    +-+-+---+      +-+-+---+      +-+-+---+
               |              |              |
              \|/            \|/            \|/
              22             15              6
```

再次强调，概念上，所有东西都是指针，序对带有指向整数的指针。

在上面的图中，我们可以讲“foo 的 car 部分”，它表示被存储在 foo （的绑定）中的值所指向的点对中的 car 字段。它是（指针指向的）10。我们常常管这个叫“表 foo 的 car 部分”。

注意，foo 的 cdr 部分也是一个表，它也是与 bar 的 cdr 部分相同的表 —— 第一个序对的 cdr 部分指向同一个表。

我们可以说，对过程 eq? 而言，foo 的 cdr 和 bar 的 cdr 是相同的，因为表达式 (eq? (cdr foo) (cdr bar)) 返回真值。也就是说， (cdr bar) 和 (cdr foo) 返回（指针指向的）完全相同的对象。

<h2 id="3.2"> </h2>

#### 3.2.表和引用

Scheme 允许你使用引用来书写字面量表。就像你能在程序中写字面量布尔值和数字一样，如果你是用特殊形式 `quote` 的话，你可以写出字面量表。

引用是个特殊形式，而不是个过程，因为它并不以通常的方式对它的参数求值。（它的参数只是数据结构的字面量表达，这看起来像一个 Scheme 表达式，但并不是。）

例如，表达式 `(quote (1 2 3))` 返回一个指向表 (1 2 3)  的指针，也就是说，一个各个 car 的值为（指针指向的）1，2，3 的，由 cdr 连接起来的序对组成的表。

你可以把 `quote` 表达式用作其他表达式的子表达式，因为它们仅仅返回和像其他任何东西一样的指针值。

例如，表达式 `(define foo (quote (1 2 3)))` 定义了（也绑定了）一个变量 foo，并将它的绑定初始化为一个（指针指向的）三元素表。

我们可以用这种方式画出结果情况：

```scheme
    +---+    +---+---+      +---+---+      +---+---+
foo | *-+--->| * | *-|----->| * | *-+----->| * | * |
    +---+    +-+-+---+      +-+-+---+      +-+-+---+
               |              |              |
              \|/            \|/            \|/
               1              2              3
```

 `quote` 只接受一个参数，并返回一个和你键入的，作为 quote 参数的数据结构的打印表示相同的数据结构。Scheme 不会对 quote 的参数以表达式的方式求值 —— 它只是给你一个指向数据结构的指针。

注意到，quote 并不构建一个（字面意义的）字符串 —— 它会构建一个可能是表，或是树，或甚至是数组的数据结构。这是非常普适的引用能力，比构建字符串对象的，在字符串两旁的双引号要强大的多。

Scheme 提供了一种更清爽的书写 qoute 表达式的方式，使用特殊的单引符 '。相比写下 (quote some-expression)，你可以使用单引号来写引用表达式。例如，我们可以用 (define foo '(1 2 3)) 写出相同的对 foo 的定义。你不需要一个回引号，这是因为 Scheme 的前缀带括号语法 —— 它能弄清引用数据结构何时结尾。

qoute 表达式便利的一点是，qoute 表达式并不在每次它被调用时创造一个数据结构 —— 对同样的表达式多次求值可能会返回许多指向同一结构的指针。

考虑过程定义

```scheme
(define (foo)
   '(1 2 3))
```

表 (1 2 3) 可能会在我们定义过程 foo 时被创建，每次我们调用 foo 时，它可能会返回指向相同表的指针。（会发生什么取决于具体的 Scheme 实现，但因为效率原因，大部分都是这样做的。对 quote 表达式求值只是取得指向之前创建的数据结构的指针。）

因为这个原因，修改从 qoute 形式返回的数据结构就是个错误。不幸的是，许多 Scheme 系统没有发现这个错误，还就让你这么干。如果你每次都需要一个新的数据结构，你应该使用像是 list 的过程，它每次总会创建一个新的数据结构。（list 是个接受任意数量参数，创造由参数组成的表的 Scheme 标准过程，我们会在之后讨论这个。）

例如，如果我们想要过程 foo 在每次调用时返回一个新的表 (1 2 3)，我们可以写成这样

```scheme
(define (foo)
   (list 1 2 3))
```

<h2 id="3.3"> </h2>

#### 3.3.空表这个名字哪来的

既然你已经理解了 Scheme 的表和单引用，我就能解释为什么空指针被叫做“空表”，并被写作 '()。

考虑三元素表：

```scheme
'(1 2 3)
```

这个表的 cdr 部分是表 (2 3)。我们可以把这个字面量写成 '(2 3)。

(2 3) 的 cdr 部分是单元素表 (3)。我们可以把这个字面量写作 '()。

(3) 的 cdr 部分是零元素表，()，也就是说，这是个空表。我们可以把这个字面量写作 '()。

考虑到 Scheme 表的工作方式，没有元素的表和空指针是同一个东西，将它打印成带有零个元素的表 ()，将它写作带有单引号的字面量 '()，这样做是很自然的。

<h2 id="3.4"> </h2>

#### 3.4.一些便利的表处理过程

Scheme 提供了多种多样的表处理过程，以便你不必考虑序对 —— 你可以考虑整个表。我会在之后更加详细地讨论这些过程，但这儿只给出简要介绍。

这些过程不会修改它们的参数 —— 它们以表作为参数，但它们会返回新的表，而不对旧的表进行修改。

##### 3.4.1.[length](#3.4.1)

##### 3.4.2.[list](#3.4.2)

##### 3.4.3.[append](#3.4.3)

##### 3.4.4.[recerse](#3.4.4)

##### 3.4.5.[member](#3.4.5)

<h2 id="3.4.1"> </h2>

##### 3.4.1.length

`length` 接受一个作为参数的表，并返回等于表长度的整数。例如，(length '(0 #t #f)) 返回 3。

<h2 id="3.4.2"> </h2>

##### 3.4.2.list

`list` 接受一个或更多参数并创建一个由参数组成的表。也就是说，一个 cdr 连接的，空表结尾的序对序列会被创建，每个序对的 car 部分会存储一个作为参数传递给 list 的值。

注意，这和 `cons` 不同， 在 `cons` 中，参数通常不是表 —— 它们只是能被放进表的物体。

直观地，我们经常使用 cons 将一个物体放入已经存在的表，但我们使用 list 来创建。

注意到，如果我们只给 list 一个参数，例如，(list 1)，这样会创建一个序对，它的 cdr 部分为空表，它的 car 部分是给定的参数。与之相较，如果我们使用 cons 来创建单元素表，我们必须用这个元素和一个空表来作为 cdr 部分的值：(cons 1 '())。

<h2 id="3.4.3"> </h2>

##### 3.4.3.append

`append` 接受两个或更多表作为参数，并创建一个带有所有参数的表。例如，

```scheme
(append '(1 2) '(3 4))
```

会返回表 (1 2 3 4)。

注意到，这和 `list` 做的不一样：

```scheme
(list '(1 2) '(3 4))
```

会返回 ((1 2)  (3 4))，一个以给定表为元素的双元素表。list 使它的参数组成新的表，这与参数使表或其他东西无关。

`append` 要求它的参数是表，并创建一个以参数表的元素为元素的表 —— 在上面这种情况下，为一个四元素表。直观上，它将给定的表连接起来。然而，它之连接第一级的结构 —— 它不会“压扁”嵌套的结构。例如

```scheme
(append '((1 2) '(3 4))
        '((5 6) '(7 8)))
```

会返回 ((1 2) (3 4) (5 6) (7 8))。

`append` 不会修改它的任何参数，但是 `append` 的结果一般会共享 `append` 得到的参数的最后一个。（它会高效地 `cons` 其他表到最后一个表来创建结果表。）因此，使用 `append` 新建一个表，之后对“旧”表进行修改的行为是危险的。这是为什么副作用在 Scheme 中很危险的原因之一。

<h2 id="3.4.4"> </h2>

##### 3.4.4.reverse

`reverse` 接受一个表作为参数，并返回一个反序的新表。

例如，

```scheme
(reverse '(1 2 3 4))
```

会返回表 (4 3 2 1)。像 `append` 一样，`reverse` 只会使一级结构反向。

```scheme
(reverse '(1 2) '(3 4))
```

会返回 ((3 4) (1 2))，而不是 ((4 3) (2 1))。

<h2 id="3.4.5"> </h2>

##### 3.4.5.member

`member` 接受一个值和一个表，并在表中搜索这个值。如果它找到了，它会返回一个指向 car 部分为该值的序对的头的指针。也就是从被搜索的对象被找到的地方开始的，“剩余的”表。如果没有找到，会返回 #f。（因此，返回值总是要么为序对，要么为假值对象。）

```scheme
(member 22 '(18 22 #f 300))
```

会返回 (22 #f 300)。

注意，`member` 既可被用于在表中找出一个值的位置，又可当作一个断言来检查这个东西在不在表中。因为序对是真值，你可以在条件表达式中使用 `member` 的结果，如果目标被找到了，结果会被算作真。

<h2 id = "4"> </h2>

### 4.数据结构之上的递归

[这节放在这里有点不合时宜 —— 需要先介绍类型和相等判定！] [那些东西在课堂上已经展示过了，所以这应该是可以理解的]

在本节中，我会演示最常见的数据结构 —— 表和数的最寻常的递归方法。

其中的一些例子将会成为像是 `length`，`list`，`append` 和 `reverse` 一样的 Scheme 标准过程实现。Schene 已经内建了这些过程，但你应该理解如何使用像是 cdr 和 cons 的简单过程来实现它们。你将不可避免地需要编写略有不同但代码类似的特殊过程。（下一章中，我会展示一些更高级的编程技巧，来让你实现像这些例子一样的，更加普遍和/或高效的过程。）

我也会展示一些其他方便的表处理过程，例如，一个表复制函数。

之后我会展示在简单二叉树上的递归。在 Scheme 中对树使用递归的普遍形式和其他你可能习惯使用的语言（如 C 或 Pascal）有些不同 —— 也更加简单。

#### 4.1.[length](#4.2)

#### 4.2.[Copying Lists](#4.2)

#### 4.3.[append 和 reverse](#4.3)

<h2 id="4.1"> </h2>

#### 4.1.length

`length` 是 Scheme 标准过程，它返回一个表的长度。它只算表节点上的元素（沿着 cdr）

使用递归时，这样做很容易。如果表是空的，它的长度就是 0；如果不是，则为 1 加上剩余表的长度。下面是定义 `length` 最简单的方法：

```scheme
(define (length lis)
   (cond ((null? lis)
          0)
         (else
          (+ 1 (length (cdr lis))))))
```

主要需要注意的事情是，这个例子是个递归结构。该过程可接受一个指向序对或空表的指针。该过程的结构直接与（恰当的）表的递归定义相对应。两条分支的 `cond` ，与两条规则描述了表的特征这个事实相对应；它弄清了我们要处理的情况。

我们显式地检查表结尾的情况，但我们隐含了假设，即处理的对象是个序对。这看起来是个不好的风格，但实际上它是好的，因为它确保了，如果 length 的参数不是空表或一个序对，将会产生错误信号 —— cond 的第二分支会被选择，但对 (cdr lis) 的求值会报错。

我们可以通过三分支 cond 来使其更清楚，带有两种合理情况和一种错误情况的分离分支：

```scheme
(define (length lis)
   (cond ((null? lis)
          0)
         ((pair? lis)
          (+ 1 (length (cdr lis))))
         (else
          (error "invalid argument to length")))
```

上面我使用了错误信号过程 `error`，它会终止程序运行并显示错误。（在多数系统中，错误信息 ”invalid argument to length“ 会被打印，用户会被展示调试这个问题的中断提示。）不幸的是，`error` 并没有被所有 Scheme 系统支持。（之后我会展示一个在所有 Scheme 系统中都能工作地相当好的实现）

在这个例子中要注意到，我使用了 lis 作为参数名，而不是 list。这是因为有一个名为 list 的 Scheme 标准过程，它会被任意同名的本地变量遮蔽。（这是因为 Scheme 的统一命名空间 —— 你不能拥有相同名字的变量和过程，原因会在之后解释。list 似乎是唯一的标识符，这通常是个问题。）

上面的 `length` 定义不是尾递归 —— 在调用自身后，必须有一个返回以便 1 能够被加给长度值并返回。稍后我会展示一个更高效的尾递归版本的 `length` 和一个名为 `reduce` 的通用过程，`reduce` 能被用来构建一系列基础算法相似的过程。

<h2 id="4.2"> </h2>

#### 4.2.Copying Lists

拷贝的普通意思有两种，（shallow copying）浅拷贝和（deep copying）深拷贝。浅拷贝得到一个对象的副本，这个副本有着和原指针指向相同的指针。

深拷贝不仅仅拷贝数据结构中的一级对象，还会拷贝一级对象里面的东西，如此递归地进行下去，这样一来，一整个新的对象被创建了。

对于由多于一个对象组成的表，把这一串表都拷贝是很有用的，也就是说沿着 cdr 进行深拷贝。我们通常将表看作一个特殊种类的对象，即便它是一个序对对象的序列。因此，拷贝”just the list“是很自然的。

如果我们只是想进行浅拷贝，我们可以定义 pair-copy 来拷贝序对，不需要拷贝其他任何东西。

在这些例子中，我会假设我们只想拷贝表结构 —— 也就是由序对连接的集合。不论何时，当我们遇到了不是序对的东西，我们会停止拷贝，得到的副本会共享原结构。（这些都不是 Scheme 标准过程。）

下面是一个真正的浅拷贝，只是拷贝了一个简单序对：

```scheme
(define (pair-copy pr)
   (cons (car pr) (cdr pr)))
```

如果我们想要进行深拷贝，我们可以使用递归来拷贝 car 或 cdr 的值，它们也是序对。下面的 pair-tree-deep-copy 的代码假设将被拷贝的结构是个由序对组成的树。 （如果有任何共享的结构，每次程序遇见时，它会被拷贝，这个副本不会含相同的结构。它总是树。在拷贝时保护共享结构更困难，但能够做到。如果有一个定向的环，pair-tree-deep-copy 会无限循环。）

```scheme
(define (pair-tree-deep-copy thing)
   (if (not (pair? thing))
       thing
       (cons (pair-tree-deep-copy (car thing))
             (pair-tree-deep-copy (cdr thing)))))
```

注意到，pair-tree-deep-copy 作用于不合适和合适的表，但只会拷贝序对。当它取得非序对的值时，它会终止并在副本中使用相同的值，副本会与原结构共享结构。

pair-tree-deep-copy 的代码直接反映了它拷贝的数据结构的种类。它能操纵非序对，非序对被假设为正在拷贝的，由序对组成的图的叶子，它也能操纵序对，序对被假设为树的内部节点。它们的 car 和 cde 值可能是树的叶子，或其他序对。

所以，对序对树的递归定义为：

-   一个非序对（叶子），或
    
-   一个序对，它的 car 和 cdr 是序对树
    

第一条规则是基础情况，也就是说，它是不需要递归的简单事情。第二条规则是递归规则，它表达了一个事实，内部节点的 car 和 cdr 字段能够指向任何序对树：一个叶子，或另一个内部节点，该节点的子树可能是叶子或其他内部节点...

这是编写针对数据结构的递归函数的简单方法 —— 弄清精确描述期望数据结构的递归表述，之后使用递归表述来写出所需结构的递归描述。你可以直接地编写遍历结构和计算结果的代码。

一般地，我们先写出基础情况，来表明递归何时结束 —— 以便我们不会忘记写出它而意外地写出无限递归或不可操纵的情况。如果你一致地这样做，你的代码可读性会更强而且你会更少犯错。

要拷贝一串真正的表，我们可以使用我们需要的结果描述：

表的副本是

-   空表（如果原表是空的话），或
    
-   （如果原表非空）一个序对，它的 car 值和原表的 car 值相同，它的 cdr 值为对原表剩余部分的拷贝。
    

下面是代码：

```scheme
(define (list-copy lis)
   (cond ((null? lis)
          '())
         (else
          (cons (car lis)
                (list-copy (cdr lis))))
```

通常，我们会检查参数来判断我们是否位于表的结尾，否则就假设参数是个序对。因为在后一种情况下，我们使用了序对的 car 和 cdr，如果参数不是真正的表，我们会得到一个错误。这通常是我们想要的，所以当 Scheme 到达具有意外结构的表的部分时，它会发出错误信号。

名字 list-copy 被选择来表明它作用于表，在 Scheme 中，术语”list”默认为“真正的表”。如果我们想要一个拷贝非真正表的函数，我们可以管它叫别的东西，并注释下它所作用的东西。

实际上，表在 Scheme 中是如此的常见，以至于我们直接叫它 copy。大多数过程名以它们操作的结构种类名开头，但表和数字例外。

<h2 id="4.3"> </h2>

#### 4.3.append 和 reverse

`append` 和 `reverse` 是两种方便的表操作；它们都是 Scheme 标准过程。

`append`接受任意数量的表作为参数，并返回一个带有所有参数的表。`reverse` 接受一个表并返回一个反序的新表。

注意到，和多数 Scheme 过程一样，它们都不带破坏性 —— 创建一个新表而不对参数有副作用（修改）。

##### 4.3.1.[append](#4.3.1)

##### 4.3.2.[reverse](#4.3.2)

<h2 id="4.3.1"> </h2>

##### 4.3.1.append

除了处理复数（多于一个）个数的表这一点外，`append` 和 list-copy 的工作方式很像。

使之正确的技巧是保持 list-copy 的基本结构，并带有正确的细微差别。

现在，我们让问题简单一点，只写出双参数的 `append` 版本，名为 `append2`。

我们的策略是对第一个表进行递归，像 list-copy 一样，在每一步中拷贝表中的一个元素。然而，当我们到达结尾时，基础情况是不同的 —— 相比于以空表将表结尾，我们使用第二个表，来作为副本的“剩余”。

注意到，当第一个表为空时，基础情况会触发 —— `append` 作用于空表和另一个表的结果就是另一个表，概念上，我们 `cons` 零个项在这个表的前面。具体而言，我们可以返回这个表。

下面是我们想要的结果的递归特征：

-   如果第一个表为空，结果就是第二个表
    
-   如果第一个表非空，结果为一个序对，它的 `car` 是第一个表的 `car`，它的 `cdr` 是`append` 作用于第一个表的剩余部分和（全部）第二个表的结果。
    

下面是一个简单的双参数版本的 `append`：

```scheme
(define (append2 lis1 lis2)
  (cond ((null? lis1)
         lis2)
        (else
         (cons (car lis1)
               (append2 (cdr lis1) lis2)))))
```

注意，`append2` 拷贝它的第一个参数，但结果仅仅与后一个表参数共享一个指针 —— 后一个表未被拷贝，因此结果与这个表共享结构。这个结论对于 Scheme 标准过程 `append` 也是正确的，`append` 能接受任意数量的表作为参数。前面的 n-1 个表被拷贝，最后一个被共享。

确保你理解了算法之上的具体操作。在递归过程中向下进行时，我们拆开第一个表，在每一步中拿出一个表元素。当到达第一个表的结尾时，递归停止然后我们返回第二个表。在回去的路上，我们 `cons` 这些项得到一个新表，回到前面。

假设我们定义了两个表， foo 和 bar，就像这样：

```scheme
(define foo '(x y z))
(define bar '(a b))
(define baz (append bar foo))
```

结果会得到与 foo 共享结构，但不与 bar 共享的 baz。通过 foo 对表的更改也可通过 baz 可见。

```
               +----------------------------------------+
               |                                        |
              \|/                                       |
    +---+    +---+---+     +---+---+      +---+---+     |
foo | +-+--->| * | *-+---->| * | *-+----->| * | * |     |
    +---+    +-+-+---+     +-+-+---+      +-+-+---+     |
               |             |              |           |
              \|/           \|/            \|/          |
               x             y              z           |
                                                        |
                                                        |
    +---+    +---+---+     +---+---+                    |
bar | *-+--->| * | *-+---->| * | * |                    |
    +---+    +-+-+---+     +-+-+---+                    |
               |             |                          |
              \|/           \|/                         |
               a             b                          |
              /|\           /|\                         |
               |             |                          |
    +---+    +---+---+     +---+---+                    |
baz | *-+--->| * | *-+---->| * | *-+--------------------+
    +---+    +---+---+     +---+---+
```

普遍上，`append` 的结果共享传递给 `append` 的最后一个参数的结构。如果你想避免这一点，你可以将空表作为传递给 `append` 的最后一个参数。例如 (append '(1 2 3) '()) 会拷贝表 (1 2 3)。

如果你担心效率问题，你要意识到，花费的时间与必须复制的表，即除最后一个表的所有表的长度成比例。这通常并不重要，但如果是对程序性能关键的部分，尤其是你要 `append` 长表，这值得考虑。

（使用 `append` 时，将短表在长表的前面，之后如果必要使用 `reverse` 是很寻常的。）

<h2 id = "4.3.2"> </h2>

##### 4.3.2.reverse

`reverse` 返回一个表的反向拷贝。

使用 `append` 来定义 `reverse` 是个容易（但效率低下）的方法。我们只需取出表的第一个元素，对表的剩余部分取反，并将第一个元素添加再表尾。我们以递归的形式来完成这件事，以便每次对表的剩余部分取反时，我们是再对更短的表做相同的事。当我们到达表尾时，取反不执行：空表的反向还是个空表。

```scheme
(define (reverse lis)
   (if (null? lis)
       '()
       (append (reverse (cdr lis))
       (list (car lis)))))
```

想想这到底是怎么运作的。`reverse` 沿着表向下递归，在每一个递归步骤中调用自己作用于表的 `cdr` 部分，直到递归在表尾停止。（最后一次调用返回空表，也就是空表的反向。）在每一步中，我们使用 `car` 来从表中取出一个元素，然后保存它，直到递归调用返回时。

通过返回，反向的表片段被传回，在每一个返回步骤中表的 `car` 被放到表的后面。（要想使用 `append` 在表尾添加单个项目，我们必须使用 `list` 将它放入单元素表中。）

最终，我们使用递归的方法从后往前构建了一个新表。在递归过程中每一步拆开一个项目，并在每一步中在新表的尾部添加一个元素。

这是个便于理解的例子，既具体又抽象。在把表拆开并在之后重新合并成一张表的过程中，你需要理解其中的具体步骤。另一方面，你也应该认识到，即便你没有注意到这点，算法仍然起作用。

一旦你掌握了递归的窍门，在不考虑其中细微步骤的情况下写出算法，或是仔细考虑其中的步骤顺序通常是很容易的。这样一来，对于是否能够使剩余的表反向，并添加第一个项目到表尾的判断是很容易的。我们不需要过多考虑操作顺序，因为操作会以我们传递给函数参数的方式向下运行。我们可以宣称“the `reverse` of a non-empty list *is* the `append` of the `reverse` of the rest of the list and (a list containing) the first item in the list”（太难翻了......），然后根据这个宣称来写出代码，并作为 （pure）纯函数 —— 只依赖于它的参数值，而没有副作用。

通过以递归形式书写，我们将对所有的表应用相同的技巧。想的更具体一点 —— 但又不是那么具体 —— 我们能够看到，在每一次我们对剩余的表进行反向操作时，问题中的表会变得更短。在某个地方，我们会碰到表尾，因此我们必须处理这个基础情况。弄明白对基础情况的正确做法通常很简单。这样一来，我们可以宣称”空表的 `reverse`就是空表“，并对 `append` 加上合适的分支。

这是个教你如何通过组合函数来得到新的函数,并在不使用副作用的情况下实现算法的绝佳例子。（注意到如果我们使用副作用，我们就必须及其慎重地考虑步骤的顺序，以确保我们在明确的变化之后使用数据结构，并且在其他（副作用）之前。）

（接下来对于效率的注解相对高深 —— 你不需要担心这些东西是否会挡在学习如何编程的道路之上。你可以跳过或忽略它们，在你领会了 Scheme 的窍门，并想要调整你的程序的速度核心部分使之达到最大的效率时回来。另一方面，你可能会发现，考虑具体细节会加深基本认识。）

然而，以如此简单的方法书写 `reverse` 会有两个问题 —— `reverse` 变成了”简单“表操作中效率最低的一个。之后我会展示更加聪明，但只是稍增复杂的更佳版本（它还会是递归的，不会使用循环和赋值操作。）

第一个问题是每次调用 `append` 所需的时间与给定表的长度成比例。（回忆一下，`append` 实际上会拷贝它的第一个参数表。）我们必须使用 `append` 来拷贝”剩余“的表，从表中的每个序对开始。平均情况下，在递归步骤中拷贝表的一般，因为我们对表中的每一个序对都进行了拷贝，我们得到了一个O($n^{2}$)的算法。

另一个问题是，我们是在递归返回的过程中进行 `append` 操作，相比于在递归过程中进行操作开销更大。就像我在之后的章节中解释的， 如果所有事情都以顺序进行，Scheme 就能够高效地进行递归 —— Scheme 能够优化除了最后一个的所有步骤和在调用前的状态保存（幸运的是，这做起来很容易。）

正是因为 Scheme 提供了内置的 `reverse`，你不必想太多。一个优秀的 Scheme 系统会提供一个高度优化的 `reverse` 实现，所用时间与表的长度成线性关系。

`reverse` 非常方便，内置 `reverse` 的效率非常重要，因为通常以简单而高效的顺序构建表，如果需要再将它反向的做法是最佳的。传统上，你每一次 `cons` 一个项目到一个表中，或是一次性 `append` 一些项目，以最简单的方式来创造表。这就允许你以线性时间构造表；有着一个线性时间的 `reverse`，整体过程仍是线性的。

==================================================================

这是 Hunk E 的结尾。

是时候试一试了。

到了这个时候，你应该阅读下一章的 Hunk F 并使用 Scheme 系统来试试例子。之后回到这里，读完这一章。

==================================================================

[Lists(Hunk F)]

<h2 id="5"> </h2>


### 5.类型和相等判定

==================================================================

Hunk G starts here:

==================================================================

因为一个指针可以指向任意类型的东西，知道它所指向东西的类型通常是一件好事。例如，你可能有一个混合着不同种类东西的表，并想要遍历这个表，对所遇到的不同种对象执行不同的操作。对于这个，Scheme 提供了类型判定，它们是检测被指针指向的对象是否为某种特定类型的过程。

你也会时常先要知道两个值是否指向相同的变量，或指向相同结构的数据结构。对于这个，Scheme 提供了相等判定。

-   5.1.[类型判定](#5.1):不同种类对象的判定
    
-   5.2.[相等判定](#5.2):判定对象是否相同
    
-   5.3.[选择相等判定](#5.3):测试不同程度的相等
    

这些过程被称作“判定”（predicate），是因为它们测试某个值是否具有某种性质，并返回是或否 —— 也就是说，布尔值 #t 或布尔值 #f。（这就像形式逻辑中的“判定”，它是一种真值取决于参数的语句。）

判定的名字一般以问号结尾，来标记它们返回一个布尔值。当你写你自己的程序时，以问号作为布尔返回值的函数名结尾是种良好风格。

（该规则的例外是像是 >，< 和 = 的标准数字比较判定。依照这个规则，它们呢应该以问号作为名称结尾，但是它们的使用非常频繁，而且人们普遍认它们作判定。我们不要应为名字中的问号所烦恼，因为它会弄乱算法表达式。）

<h2 id = "5.1"> </h2>

#### 5.1.类型判定

Scheme 提供了内置的过程来测试指针指向的对象是否为特定类型。如果你想要知道 x 的值是否为（一个指针指向的）序对，你可以使用判定 `pair?`，就像这样：(pair? x)。

相同的，如果你想要知道某个东西是否为一个数字，你可以使用判定 `number?` 。如果你想要知道某个值是否为整数，而不是其他类型的数，你可以使用 `integer?`。

其他的一些类型判定也被提供给一些我们将要讨论的数据类型，包括 `string?`， `character?`，`vector?` 和 `port?`。

<h2 id = "5.2"> </h2>

#### 5.2.相等判定

相等判定用来区分一个值是否和另一个“相等”，这儿实际上有几种意义上的“相等”，因此 Scheme 提供了 4 种相等判定。

有时你想知道两个数据结构是否从结构上是相等的，是否有相同的值和相同的地址。例如，你可能想知道一个表是否与另一个表有着相同的结构和元素。对于这一点，你可以使用 `equal?`，它会进行一个深度的，元素级别的结构比较。

例如 (equal? '(1 2 3) '(1 2 3)) 返回 #t，因为参数都是包含 1，2，3 并以这个顺序构成的表。`equal?` 会对数据结构进行深度的遍历，因此你可以在嵌套的表或其他相当复杂的数据结构上使用它。（然而，不要将它用在带有环指针的结构上，这样可能会进入无法结束的死循环。
#|注：就像 C 中的环链表 |#

`equal?` 对简单的东西同样有用。例如，(equal? 22 22) 返回 #t，(equal? #t 5) 返回 #f。（注意到 equal? 可被用于比较类型不相同的东西，但如果类型是不同的，结果总是 #f。不同类型的对象永远不会 equal。）

通常你不会想要比较两个完全的数据结构 —— 你只是想要知道它们是否是精确相同的对象。（#| 原文：exact same object，也就是比较指针的值是否相等|#）例如，给定两个指向表的指针，你可能想要知道指针们是否指向同一个表，而不是分别指向两个元素相同的表。

对于这一点，你可以使用 `eq?`。`eq?` 比较两个值来判断它们是否指向相同的对象。因为 Scheme 中所有的值（观念上）都是指针，这就是个指针比较，所以 `eq?` 很快。

（你可能会想带标记的直接值表示会使 eq? 比简单的指针比较更慢，因为它不得不检查比较的东西是不是真的指针。实际上并不是这样 —— eq? 只是比较了位组合而不关心比较对象是代表指针还是直接值。）

对数字的相等判定得到了特殊对待。当比较两个数值时，= 是合适的判定。使用 = 有着这样的优点：当 = 被用于非数字值时会出错，Scheme 会在这时进行抱怨。如果你犯了个错误，在本应是数字的地方放了个非数字，Scheme 通常会提示你。（你也可以用 equal?，但是在应用于非数字时，它不会报错，而且 equal? 可能会慢一点。）

还有另外一个相等判定，eqv?，eqv? 进行数字比较（就像 =），和相等判定（像 eq?）

==================================================================

这是 Hunk G 的结尾

是时候试一试了

这个时候，你应该去看下一章的 Hunk H，使用Scheme 系统来过一遍例子。之后回来，继续这一章。

==================================================================

<h2 id = "5.3">  </h2>

#### 5.3.选择相等判定

==================================================================

Hunk I starts here:

==================================================================

`=` 和 `eqv?` 都被需要的原因是 Scheme 的数字系统，因为效率的原因，不像想象的那么清晰。

理想情况下，对任何数都有一个副本，所有出现的数字都应该是指向相同且唯一的对象。接下来你就可以使用 `eq?` 进行相等判断，就像你可以将 `eq?` 用于其他类型的值一样。（例如，这样只会有一个浮点数表示 2.36529，任何返回这个浮点数的计算都会返回指向这个唯一对象的指针。（(eq? 2.36529 2.36529) 会返回 #t）

不幸的是，对数字来说，这样做的代价太过昂贵 —— 它需要在系统中一直保持一个包含所有数字的表，并利用这张表来消除对相同值的复制拷贝。作为对效率的妥协，Scheme 允许同一数字存在多个副本，`=` 和 `eqv?` 判定掩盖了这一赘余 —— 处理数字时，它们进行数值比较，这样一来，你不必单型两个有相同数值的数值是否是相同的对象。

`eqv?` 因此检测两个值是否是“相等的”，当两个对象有相同数值时，它们被当作“相等”，像 = 一样，但对所有其他对象，都被以对象相等进行区分，就像 `eq?` 一样。

一般而言：

-   `eq?` 在对非数值进行快速相等判定时很有用，
    
-   `=` 对数字进行数值比较，
    
-   `eqv?` 像 `eq?` 一样，除了认为相同数字的副本是相同对象这一点，
    
-   `equal?` 对数据结构进行“深度”的比较（它使用 eqv? 对结构中的数字进行判定）

<h2 id = "6"> </h2>

### 6. 引用和字面量

程序经常需要引用字面量数据 —— 你直接在程序中输入的数据。在许多语言中，只有相当简单的字面量，比如整数和字符串。在 Scheme 中，你可以使用简单或复杂的字面量来表示（指针指向的）数据结构，比如嵌套表。早些时候，我展示了如何使用引用来创造字面量表。

你可能注意到了，Scheme 代码的语法和 Scheme 数据的文本表示非常相似。例如，如果看作代码，`(min 1 2)` 就是个组合式，但它也容纳符号 `min` 和整数 `1` 和 `2` 的表的标准文本表示。

（一个符号是一个有点像字符串的数据对象，但同时有着特殊的性质，这将会在之后几章进行解释）

第一件需要理解的事情是 quoting。在 Scheme 中，表达式 `(min 1 2)` 是对`min`的过程调用，带有参数 1 和 2。

就像我在之前解释的，我们可以通过将它使用特殊形式 (quote ...) 来引用它，并得到字面量表 (min 1 2)。

例如，定义

(define foo (quote (min 1 2)))

定义并绑定 foo，使用（指针指向的）表 (1 2 3) 将绑定初始化。

我们可以这样画出这个情况：

```scheme
    +---+    +---+---+      +---+---+     +---+---+
foo | *-|--->| * | *-+----->| * | *-+---->| * | * |
    +---+    +---+---+      +---+---+     +---+---+
               |              |             |
              \|/            \|/           \|/
              min             1             2
```

当然，就像我之前解释的，我们可以使用`'`'作为`(quote ...)` 的委婉（euphemism）写法

我们可以用这种方法定义出非常复杂的字面量，如果我们想要这样的话。这是一个过程，它返回一个由整数，布尔值，符号组成的表的嵌套的嵌套。

```scheme
(define (fubear)
   '(((1 two #f) (#t 3 four))
     ((five #f 6) (seven 8 #t))
     ((#f 9 10)) ((11 12 #f))))
```

这是个相当没用的过程，但输入嵌套数据结构的打印表示，来让 Scheme 为你自动构造它们是非常方便的。在许多语言中，你不得不做一些实在是琐碎的工作来像这样构造一个表。我们将在之后的章节中看到，Scheme 也支持 *准引用* （quasiquotation），它允许你构造大体上的（mostly-literal）字面量数据结构，并轻松创造自定义的变体；`quasiquotation` 会在下一章被讨论。

#|注：准引用相当灵活，好玩且强大 |#

#### 简单字面量和自求值（self-Evaluation）

你现在可能已经注意到了，我们已经在例子中大量地使用了字面量 —— 数字字面量和布尔字面量。为什么我们不必`quote` 它们来避免 Scheme 尝试对它们求值，就像其他表达式一样？因为 Scheme 有一个特殊规则，那就是：数字的值和布尔量的值就是数字和布尔值。对这些数据类型而言，尝试对它求值的结果和你开始使用的值相同。所以，4 的值就是 4，#f 的值就是 #f。（这对于其他的一些类型同样奏效，例如字符和字符串。）Scheme 能让你像输入表达式一样输入某个值的文本表示，按照惯例，这个表达式的值就是你输入的文本表示形式的值。这样的表达式被称为 *自求值* （self-evaluating），因为对它求值得到它自己。

这条规则的深层意义是什么？并没有什么。它只是让你不需要输入一大堆的`quote` 来使用简单字面量。请注意，这意味着如果你想要的话，你可以`quote` 一个数字或布尔值，但这样不会带来什么不同。表达式`'0` 意为“字面上的数字 0”，但因为 Scheme 将数字的值定义为数字本身，`'0` 的值就是 0。

与之相似，`'#f` 或 `(quote #f)` 的值都和 #f 一样 —— 它们都是指向 假 对象的指针。你可以这样写字面量 "foo" ：`'"foo"` 。不管是哪一种，表达式的值就是指向字符串对象的指针，该字符串序列是 f o o。

次要警告：不要在已经被 quote 的表达式内添加额外的 `quote` 。`'(foo 10 baz)` 和 `'('foo '10 'baz)` 不是同一个东西。对一个字面量表达式而言，一个 `quote` 已经够了，在 `quote` 中额外的 `quote` 会让你在理解引用的工作方式之前会做出令你惊奇的行为。

在 Scheme 中，对大多数部分而言，表达式求值是很简单的，但你必须记住对特殊形式的求值规则（特殊形式不一定总是对参数求值）和自求值的规则。之后，我会向你展示，通过在对表达式求值之前先进性分析，一个解释器是如何实现自求值的。稍后，我会展示一个编译器如何在编译的时候做同样的工作，以便使用字面量不会在运行时花费任何求值开销。

<h2 id = "7">  </h2>

### 7.局部变量和词法作用域

Scheme 是一个带有嵌套作用域的块结构语言。你可以声明局部变量，它的作用域是一个代码块，代码块可以内含具有局部变量的代码块。

Scheme 使用词法作用域规则。（我们可以这样说，Scheme 是静态作用域的，而不是像老式 Lisp 一样的动态作用域）但你在代码中看到一个变量名时，你可以通过查看程序的源代码来分辨它所指向的变量。程序由可能嵌套的代码块组成，名字的意义由它内部使用的变量绑定构造所决定。

-   7.1.[let](#7.1) ：let binds local variables
    
-   7.2.[词法作用域](#7.2) ：lexical scope
    
-   7.3.[let*](#7.3) ：`let*` binds variables sequentially, in nested scopes
    

<h2 id = "7.1">  </h2>

#### 7.1.let

你可以使用特殊形式 `let` 来创建含有局部变量的代码块。

你已经在其他语言中看见过局部绑定环境。在 C 或 Pascal 你可能已经看到过带有私有局部变量的块，例如，在 C 中：

```c
...
{
    int x = 10;
    int y = 20;

    foo(x, y);
}
...
```

这样我们得到了一个块。（在大括号中）在其中，名为 x 和 y 的局部变量是可见的（同样的工作可以通过使用 begin ... end 在 Pascal 中完成。）

当我们进入块时，内存会被分配给局部变量并被初始化为合理的初始值。我们说，当进入块时，变量是绑定的 —— 名字 x 和 y 指向某些东西，也就是为它们分配的内存。（在 C 中，为局部变量分配的内存可能被分配在栈（activation stack）上。

这是个简单但重要的概念 —— 当你进入一个作用域的时候，你将名字“绑定”给内存，创建在名字与存放值的地方之间的关联。（在之后的章节中，我们会看到解释器和编译器是如何跟踪变量和内存之间的联系的。）

有时，我们将为变量分配的内存称为”变量的绑定“，但实际上这是“以变量命名的内存”，或“与变量相绑定”的缩写。

在块中，所有对变量 x 和 y 的引用都指向这些新的变量绑定。当执行到块的结尾时，这些变量绑定不再存在，对 x 或 y 的引用将再次指向它们先前在块的外面所指的东西。（可能是全局变量，或中间界别的块变量，或什么也没有）。

在这个例子中，在块内发生的只是对过程 foo 的调用，使用块变量的值，也就是 10 和 20。在 C 或 Pascal 中，当进入一个块时，这些临时变量可能以增序的形式分配在栈上，当退出块时，变量依次减序释放。

在 Scheme 中，事情很相似。块可以由 `let` 表达式创造，像这样：

```scheme
...
(let ((x 10)
      (y 20))
   (foo x y))
...
```

`let` 的第一部分是变量绑定语句，上面这种情况有两条子句，(x 10) 和 (y 20)。这表明 `let` 会创建一个初始值为 10 的变量 x，和另一个初始值为 20 的变量 y。`let` 的变量绑定语句可以容纳任意数量的子句，创建任意数量的 `let` 变量。每一条子句和 `define` 的名字和初始化部分非常相似。

`let` 的剩余部分是一个表达式序列，被称为 let体（let body）。表达式会被顺序求值，最后一个表达式的值会被作为整个 let表达式 的值返回。（这一点非常方便，并在我们之后使用的例子中起重要作用。）

`let` 可以只绑定一个变量，但对整个变量绑定语句，以及特定的一个子绑定，仍然需要用括号括起。例如：

```scheme
...
(let ((x 10))
   (foo x))
...
```

（不要忘了变量绑定语句两旁“额外的”括号 —— 它们并不是额外的，因为正是它们告诉了 Scheme 变量绑定语句的开头和结尾。在上面这种情况，括号在定义了一个变量的子句之前和之后。）

在 Scheme 中，你可以像你在大多数语言中一样使用局部变量。当进入一个 let表达式 的时候，let变量 会被绑定并初始化。当推出 let表达式 时，那些绑定会消失。

然而，你也可以以不同的方式来使用 let变量，我们会在之后的章节中解释。一般而言，Scheme 变量的绑定不是分配在栈上的，而是在堆上。这允许你仍然持有绑定，即使在创造这些变量的过程结束之后，这一点很有用。

（你可能会认为这样做不够高效，的确如此，但是好的 Scheme 编译器总是能够判断不必将大多数变量放在堆上，从而避免堆分配的开销。与大多数语言的优秀编译器一样，大多数变量在关键的时候实际上都在寄存器中，因此生成的代码很快。

#### let表达式的缩进

一般而言，我们使用能够体现程序的块结构的方式来缩进 let表达式。绑定（变量名和初始值）是在 `let` 的垂直方向排列，let表达式 的体缩进几个字符并且垂直排列，像这样：

```scheme
(let ((x 10)
      (y 20))
  (foo x)
  (let ((a (bar))
        (b (baz)))
    (quux x a)
    (quux y b))
  (baz))
```

注意到，每个 `let` 的绑定部分都是垂直排列的，而且 表达式体缩进的没有那么远。这对于体现绑定的结束和表达式体的开始是很重要的。（在这个例子中，外部 `let` 的表达式体由一个对 foo 的调用、另一个 let 和一个对 baz 的调用组成。内部 `let` 的表达式体由两个对 quux 的调用组成。

<h2 id = "7.2">  </h2>

#### 7.2.词法作用域

如果嵌套的 let 定义了多个相同名字的变量，在内层 `let` 中使用的变量名会指向由内层 `let` 所创建的绑定。

考虑下面的代码片段：

```scheme
(let ((x 10)    ; outer binding of x
      (a 20))   ; binding of a
   (foo x)
   (let ((x (bar))       ; inner binding of x
         (b (baz x x)))  ; binding of b
      (quux x a)
      (quux y b))
   (baz x a)  ; refers to outer x (and a)
   (baz x b)) ; illegal?
```

当进入外层 `let` 时，为变量准备的初始值会被计算。在这个例子中，初始值是字面量值 10 和 20。内存会被分配给变量，并以这些值进行初始化。这些工作一旦完成，名字 x 和 a 的意义就变了 —— 它们现在指向为 let变量 x 和 a 分配的新的内存 —— 之后，表达式体会被求值。

与之相似，当进入内层 `let` 时，初始值会通过调用 bar 和 baz 得到计算，之后内存会被分配给 x 和 b 并以这些值进行初始化。之后，x 和 b 的意义发生改变，变为指向这些变量（绑定的）的内存。（例如，表达式 (baz x x) 被求值的时候，x 仍为 10，因为 x 仍然指向外部的 x。）

在这个例子中，当进入内部 `let` 时，标识符 x 的意义发生了改变。我们称之为：在内部`let` 的表达式体中，内部的 let变量 x 隐藏了外部的 `let` 。外部的 x 不再可见，因为这时内部的 x 是可见的。

当我们退出一个 `let` （在对表达式体求值后），被 `let` 引入的绑定便“脱离了作用域”（go out of scope），也就是不再可见了。例如，但我们在外部 `let` 的表达式体中对 (baz x a) 进行求值时，x 指向由外部 `let` 所引入的绑定 —— 由内部 `let` 引入的绑定不再可见。

同样，在示例代码片段中，在最后一个表达式 (baz x b) 中的 b 并未指向由内部 `let` 绑定的 b。除非还有一个在外部作用域中的尚未展示的对 b 的绑定（例如 全局绑定（top-level）），这样做就是个错的。

-   [绑定环境和绑定界限（Contours）](#7.2.1)
    
-   [块结构示意图](#7.2.2)：作用域可视化
    

<h2 id = "7.2.1">  </h2>

#### 绑定环境和绑定界限

在程序执行的某一个点，所有可见的绑定被称为一个绑定环境。也就是，绑定环境将名字集合映射到相应的内存。

全局绑定环境是 Scheme 系统维持的全局变量和它们所绑定的内存之间的映射关系。这可以通过哈希表来实现。

遇到局部变量时，简单的“扁平”表是不够的。例如，进入 `let` 就会向正在执行的环境添加新的绑定 —— 它会使新变量的绑定可见，改变了名字到内存的映射关系。

我们将每一个我们执行的每一个绑定构造称之为新的绑定界限。（binding contour）我们称之为界限，因为它改变了环境的“形状“。

你可以把绑定界限想作：在进入`let` 的时候或创建绑定变量的时候，通过创建新的表来实现。当 Scheme 寻找一个标识符的绑定时，它首先在新表中查找，之后在代表 `let` 外部环境的表中查找。因为 Scheme 首先在“内部”环境的表中进行查找，它总会找到任意标识符的最内层绑定，就像之前 x 的例子。

在任意的时间节点，环境由所有可见变量绑定组成。这包括了所有最内层界限的绑定，和所有表中嵌套的界限的所有绑定，但相同名称的内部绑定所隐藏的绑定除外。

<h2 id = "7.2.2">  </h2>

#### lets 的块结构示意图

通过画出块结构示意图来表现出不同变量的可见性，我们可以使环境和界限显得更加清晰。

```
(let ((x 10)    ; bindings of x
      (a 20))   ; and a 
 +----------------------------------------------------------+
 | (foo x)                                 scope of outer x |
 | (let ((x (bar))                           and a          |
 |       (b (baz x x)))                                     |
 |  +------------------------------------------------+      |
 |  | (quux x a)                    scope of inner x |      |
 |  | (quux y b)                    and b            | )    |
 |  +------------------------------------------------+      |
 | (baz x a)                                                |
 | (baz x b)                                                | )
 +----------------------------------------------------------+
```

（这种块示意图就是术语“块结构”的起源）

每个框代表一个界限：它表现出了在程序中的哪些地方变量绑定是可见的。

我们可以通过观察变量名的外部和使用对应于改变量名的绑定的最接近的封闭框来解释块结构示意图。现在我们可以看到，最终调用 (baz x b) 并没有指向 let变量 b —— 它不在对应于变量 b 的方框里。我们也可以看到，在这个表达式中出现的 x 指向外层的 x。在对 quux 的调用中出现的 x 指向内层 x，因为它们在框的里面，内层定义隐藏了外层定义。

这儿还有些微妙的东西需要注意。当我们对内部 `let` 的初始化表达式求值时，内部绑定还并不是可见的。x 仍然指向 x 的外部绑定，而不是将要创建的内部绑定。有时候，这正是你所需要的，但有时候又不是。因为它不总是你所需的， Scheme 提供了两个 `let` 的变体，它们叫做 `let*` 和 `letrec` 。

<h2 id = "7.3"> </h2>

### let*

对大多数局部变量来说，let是很有用的，但有时你想要按顺序创建一些局部变量，而且让每一个变量对下一个变量可见。

例如，“解构”数据结构的时候，提取出部分结构，再提取出部分的部分是很寻常的。我们可以通过嵌套表达式来进行提取，但这样一来我们就没有可理解的直接名字来表达嵌套表达式的结果。

（这种情况下，我们可能想要使用某一个嵌套表达式不止一次，因此我们需要创建一个变量作为对表达式的引用。）

看看下面的代码片段：

```
(let ((a-structure (some-procedure)))
   (let ((a-substructure (get-some-subpart a-structure)))
      (let ((a-subsubstructure (get-another-subpart a-substructure)))
         (foo a-substructure))))
```

Scheme 提供了一个方便的语法，用来处理嵌套 `let` ；上面的代码可以只使用一个 `let*` 来完成。

```scheme
(let* ((a-structure (some-procedure))
       (a-substructure (get-some-subpart a-structure))
       (a-subsubstructure (get-another-subpart a-substructure)))
   (foo a-substructure))
```

注意到，使用普通的 `let` 来绑定这三个变量是不行的。块结构示意图展示了原因：

```scheme
(let ((a-structure (some-procedure))
      (a-substructure (get-some-subpart a-structure))
      (a-subsubstructure (get-another-subpart a-substructure)))
 +---------------------------------------------------------------+
 | (foo a-substructure)           ; scope of all three variables | 

 +---------------------------------------------------------------+
 )
```

现在我们可以看到，所有 let变量 的初始值都在任意变量的作用域的外面。a-substructure 和 a-substructure 不会指向被 `let` 引入的绑定，而是会指向在 `let` 外面的任意可见的绑定。

使用 `let*` ，结果就不同了：

```scheme
(let* ((a-structure (some-procedure))
 +-------------------------------------------------------------------+
 |     (a-substructure (get-some-subpart a-structure))               |
 +----------------------------------------------------------------+  |
 |     (a-subsubstructure (get-another-subpart a-substructure)))  |  |
 +-------------------------------------------------------------+  |  |
 | (foo a-subsubtructure)                                      |  |  | )
 +-------------------------------------------------------------+--+--+
```

在 `let*` 中，每个初始值语句都位于先前变量的作用域中。从嵌套框图中，我们可以看出，每一条初始化语句之后，对应的绑定变得可见，因此绑定的值可以用于计算下一个绑定的初始值。

在 Scheme 中，还有另一个局部绑定构造，`letrec` ，它被用来创建相互递归的局部过程。我会在之后讨论这个东西，当我描述局部过程在 Scheme 中的工作方式的时候。

==================================================================

This is the end of Hunk I

TIME TO TRY IT OUT

At this point, you should go read Hunk J of the next chapter and work through the examples using a running Scheme system. Then return here and resume this chapter.

==================================================================

<h2 id = "8">  </h2>

### 8.过程

==================================================================

Hunk K starts here:

==================================================================

Scheme 过程是“一等公民”，这意味着它们是语言中的对象。它们可以是匿名的，这意味着你可以使用指针指向不必拥有名字的过程。它们可以是高阶的，这意味着过程能够操作过程。

-   8.1.[一等过程](#8.1)：Procedures are objects in the language
    
-   8.2.[高阶过程](#8.2)：Procedures can take procedures as arguments
    
-   8.3.[匿名过程和 lambda](#8.3)：lambda creates procedure objects, which don't need names
    
-   8.4.[lambda 和词法作用域](#8.4)
    
-   8.5.[局部定义](#8.5)：defines work locally, too
    
-   8.6.[局部递归过程和 letrec](#8.6)：letrec is like let, but supports recursive definitions
    
-   8.7.[多重定义就像 letrec](#8.7)：Understanding definitions are scope
    
-   8.8.[可变参数](#8.8)：Procedures can take a variable number of arguments
    
-   8.9.[apply](#8.9)
    

<h2 id = "8.1"> </h2>

#### 8.1.过程是一等的

在 Scheme 中，过程就是数据对象 —— 就像你可以对其他 Scheme 值做的一样，你可以使用指针指向一个过程。从术语上说，我们说过程在 Scheme 语言中是一等公民 —— 你可以将过程作为参数传递给过程，将它作为过程的返回值，将它存储在变量或其他的对象中。过程指针只是一个值，你可以像其他任何值一样传递这个值，比如序对和布尔值。

当然，过程是特殊的，因为它是唯一支持过程调用操作的对象。

在 Scheme 术语中，过程调用被称为 组合（combination）。对组合的求值包括对参数表达式的求值和将过程应用于这些过程，也就是使用这些参数调用过程（将过程应用于这些参数）。

Scheme 的一个不寻常的特性在于它使用单命名空间（unified namespace），这意味着对于变量和过程，只有一种名字 —— 事实上，过程名就是变量名，只有一种变量。一个命名的过程真的就只是一个碰巧由变量引用的一等过程对象。

回忆下 min 的定义：

```scheme
(define (min a b)
   (if (< a b)
       a
       b))
```

当你像这样定义一个过程时，你实际上做了三件事：创建一个过程，创建一个普通变量（名为 min），并且将变量初始化为指向过程的指针。

（这意味着你不能在同一作用域中拥有相同名字的“普通”变量和过程变量 —— 这儿只有一种变量，所以你只能在给定作用域中拥有一个绑定。）

当你像上面定义 min 的例子一样定义一个过程时，不由被过程定义的特殊语法搞糊涂了 —— 过程名真的只是个变量名，只是碰巧以过程作为变量的值罢了。通过将变量值存入变量，你可以以这种方式使用任意变量。你也可以将新的过程值赋给变量，之后使用它来作为新的过程名。

例如，如果你在上面已经定义了 min，你可以通过 `(set! min +)` 改变 min 的绑定。这个赋值表达式会寻找变量 `+` ，然后将它的值赋给变量 min，`+` 是加法过程。

之后你可以像之前一样调用 min，但是它会进行加法操作，因为它会调用和`+` 一样的过程。例如 (min 5 10) 会返回 15，而不是 5。

你也可以改变 `+` 的意思，只需将一个新的值赋给变量 `+` （的绑定）。除非你有充分的理由，这样做很可能是个坏注意，因为如果新的过程不进行加法运算，对 `+` 的调用会返回不同的结果！

理解在 Scheme 中过程调用的工作方式是很重要的，它也非常简单。考虑组合（过程调用表达式） (+ a b)。它的真正意义是

-   1.查找变量 + （当前绑定）的值，我们假设它为一个过程，
    
-   2.查找变量 a 和 b（当前绑定）的值，
    
-   3.将过程应用于这些值，也就是用这些值调用过程。
    

组合 的第一个子表达式就像其他东西一样被求值，即便结果的使用方式不同。第一个子表达式是一个应该以过程作为返回值的表达式，其他子表达式返回传递给过程的参数。

如果第一个子表达式的值不是过程的话，过程调用不会成功。例如，你可以使用赋值表达式 (set! + 3) 改变 `+` 的意义。之后如果你尝试使用组合 (+ 2 3) 来调用 `+` ，你会得到一个错误。Scheme 可能会说像是 “ERROR:Attempt to apply non-procdudre.”

第一个子表达式的求值方式就像其他表达式这一点是非常有用的。相比使用特定过程的名字进行过程调用，你可以使用任意返回值为过程的表达式。例如，我们可能有一个装有在不同情况下使用的不同过程的表，在特定的时候，在表中找到特定的过程：

```scheme
((look-up-appropriate-procedure key) foo bar)
```

这儿我们使用参数 key 对过程 look-up-appropriate-procedure 进行调用来得到一个过程，然后将它应用于 foo 和 bar。

对 组合 的警告： Scheme 并没有对 组合 的子表达式的求值顺序进行要求。不要编写依赖于首先计算运算符表达式，或是根据参数表达式的计算顺序的代码。

你可能会想一等过程为什么这么特殊，因为其他语言（比如 C）允许你传递函数指针给过程，也允许使用指针调用过程。如果你使用 Pascal 所允许的那一套，Scheme 的过程就像 Pascal 的一样，但是 Scheme 允许你以更一般的方式使用它们，就像我在之后解释的方法那样。

<h2 id = "8.2"> </h2>

#### 8.2高阶过程

Scheme 在设计上就能够方便的使用高阶（high-order）过程，即，过程可以将过程作为参数并返回过程。

例如，能够很容易地写出一个排序过程，它接受一个进行比较的过程作为参数，并使用你传递给它的过程来决定排序的顺序。

为了将表排序为升序，你可以使用过程 `<` （"less than"）来调用 sort，像这样：

```scheme
(sort < '(5 2 3))
```

然后你会得到排序好的表 (2 3 5)。

注意，表达式 `<` 只是个变量引用。我们求得变量 `<` 的值并将它作为参数传递给 `sort` 。

如果你想将表排位降序，你可以将 `>` （"greater than"）作为参数传递给 `sort` 。

```scheme
(sort > '(5 2 3))
```

然后得到有序表 (5 3 2)。

同样的过程可以用来处理不同种类的对象，只要你提供能够进行你想要进行的比较的过程。

例如，将字符串以字典序排列，你可以传递给 `sort` 一个指向标准字符串比较过程 `string?<` 的指针，

```scheme
(sort string
```

然后得到表 ("bar" "baz" "foo" "quux")

[[give map expample here?]]

<h2 id = "8.3"> </h2>

#### 8.3.匿名过程和 lambda

Scheme 有一个非常特殊的特殊形式，它叫做 `lambda` 。它创建一等过程并返回指向过程的指针。

例如，你可以通过对表达式 (lambda (x) (+ x x)) 的求值得到一个能将参数翻倍的过程。这个表达式的第二个子形式是形式参数的列表，第三个子形式是过程体。

`lambda` 不会为它创建的过程命名 —— 它只是返回指向过程对象的指针。

事实上，过程定义的变体 `define` 与用于定义变量的 `define` 是等价的，过程定义使用的 `define` 使用 lambda表达式 作为初始值形式。

例如，

```scheme
(define (double x)
   (+ x x))
(define double (lambda (x)
                  (+ x x)))
```

两者是等价的。

不管是哪一种，我们都创建了一个单参数过程，我们也定义并绑定了一个名为 double 的变量，并将它的内存初始化为一个指向过程的指针。

`define` 的过程定义语法只是语法糖（syntactic sugar） —— 并没有你只能用 `define` 做而不能使用局部变量和 `lambda` 做的事。它只不过是相同事物的一个更方便的记号罢了。

==================================================================

This is the end of Hunk K.

TIME TO TRY IT OUT

At this point, you should go read Hunk L of the next chapter and work through the examples using a running Scheme system. Then return here and resume this chapter.

==================================================================

<h2 id = "8.4"> </h2>

#### 8.4.lambda 和词法作用域

==================================================================

Hunk M starts here:

==================================================================

lambda 创建一个过程，该过程可在对这个 lambda 表达式求值的作用域中执行。

除了过程自己的局部变量（包括参数），过程中的名字会指向在该过程被创建的时候指向的任何东西。

被过程创建的局部变量在过程体中具有通常的作用域规则。（参数变量是一种特殊的局部变量，它们从主调者（caller）处获得初始值。其他的变量被称为自由（free）变量 —— 也就是在过程外面定义，却在过程内部引用的变量。

我们说，lambda 在创建过程时，创建了一个闭包。过程在被创建时，它的自由变量引用是“固定”的。每当过程引用自由变量时，它会指向创建过程时的环境中的变量。

看看下面的小程序

```scheme
(define foo 1)

(define (baz)
   foo)

(define (quux)
   (let ((foo 6))
      (baz)))

(quux)
```

当 quux 被调用时，它会绑定它的局部变量 foo 并调用 baz。然而，当 baz 从 quux 处被调用时，它仍然会看到顶级绑定 foo，这里的 foo 的值是 1。对 baz 调用的结果是 1，并且这个值也会被作为调用 quux 的返回值。

这样做是有很好的理由的，而且这个规则也被绝大多数的编程语言所使用。在定义过程的位置就固定过程的含义，而不是让它的含义取决于它的调用位置，这一点很重要。你想要能够看到代码，并看到名字 foo 所指向的特定变量，也就是在顶层的可见变量。你不想要担心过程 baz 的意义根据它的从何处调用而发生变化。

块结构示意图可能会显示的更清楚。我只向你展示部分的过程 baz：

```scheme
(define (quux)
   (let ((foo 6))
     +---------------------------+
     | (baz)        scope of foo | ))
     +---------------------------+
```

这强调了局部变量 foo 真的是局部的。baz 的定义并不在这个盒子中，所以它看不见 quux（这里原文为 foo，疑似错误） 的局部变量 foo。（baz 被从盒子里面调用这一点并不重要。）

概念上，过程 baz 向在它执行前它被创建的环境进行返回，甚至在绑定其参数之前创建它的环境之前。

在早期的 Lisps 中，使用着一种不同的规则，它叫做动态作用域（dynamic scope）。在这些 Lisp 中，对 baz 的调用会看见最近绑定的 foo。在这种情况下，它会看见在调用 foo 之前被 quux 创建的绑定。这会导致非常难以理解的错误，因为过程有时正常工作，有时又不行，这取决于在其他过程中绑定的变量名。

（动态作用域被普遍认为是一个重大错误，在最近的 Lisp 版本中得到了修复，比如 Common Lisp，它受到了 Scheme 的影响。）

<h2 id = "8.5"> </h2>

#### 8.5.局部定义

Scheme 允许你定义作用域在过程或带有局部变量的块中的局部过程。这就让你“隐藏”只在特定上下文中有意义的过程，以便你只在这个上下文中使用它。

你可以使用 let 和 lambda 定义局部过程，像这样：

```scheme
(define (quadruple x)
   (let ((double (lambda (x)
                    (+ x x))))
      (double (double x))))
```

这里，我们定义了一个叫做 quadruple 的过程，它带有一个叫做 double 的局部变量；它的值是一个由 lambda 创建的，会将参数值增倍的过程。

注意到，当我们从过程 quadruple 的内部调用 double 时，我们通过它的名字 doulbe 进行调用，double 是这个局部变量的名字。这当然可以，因为变量名和过程名并没有什么区别 —— 对命名过程的调用始终首先是对变量值的查找，然后是对它所指向的过程的调用。

同样注意到，内部过程的参数 x 隐藏了外部过程的参数 x。在 double 的过程体中，它指向 double 的参数，但在外面并不是。（如果我们选择不同的名字来表示这两个过程的参数的话，代码读起来会更容易，但在这里是用作阐述。）

和顶级定义一样，我们可以通过使用 define 代替 let 来写出局部定义。例如，我们可以把上面的过程这样写：

```scheme
(define (quadruple x)
   (define (double x)      ; define a local procedure double
      (+ x x))
   (double (double x)))    ; nested calls to the local procedure
```

局部 `define` 和使用 `lambda` 的 `let` 很像。（实际上，它就像是使用 `lambda` 的`letrec` ， 但是我们还没有讨论 `letrec` ；我们在之后讨论。）

对内部 `define` 有一条限定 —— 它们必须在过程体的开头（或在其他各种体的开头，比如 let体，`define` 要在一般可执行表达式的前面。）

局部过程定义服从一般的词法作用域规则，像嵌套 `let` 一样。例如，在上面的例子中，double 的形参 x 归属于 doulbe 过程体 —— 它与 quadruple 的参数 x 不同。

```scheme
(define (quadruple x)
   (define (double x)
 +------------------------+
 |     +--------+         |
 |     | (+ x x)|)        |
 |     +--------+         |
 |  (double (double x))   | )
 +------------------------+
```

里面的盒子是 doulbe 参数 x 的作用域，外面的那个是变量 doulbe 的作用域。

我们可以为局部过程的参数使用不同的名字，这样做不会改变不论哪一个过程的意义：

```scheme
(define (quadruple x)
   (define (double y)    ; local defn. of double
      (+ y y))           ; body of local procedure
   (double (double x)))  ; body of quadruple
```

另一方面，因为这里没有对 `+` 的局部绑定，`+` 指向定义 quadruple 的上下文中它所值的任何东西。假设 quadruple 是个顶级过程，而不是在其他作用域中的局部过程，`+` 指向顶级绑定的 `+` 。（记住，过程名就是个变量名，所以针对变量的作用域规则同样适用于过程名。）

<h2 id = "8.6"> </h2>

#### 8.6.局部递归过程和 letrec

使用 `let` 和 `lambda` 来定义局部过程通常是可行的，但是一般来说我们会用 `letrec` 而不是 `let` ，因为它支持*递归* 的局部过程。（这也是为什么它被称为 letrec —— 它表示带有递归的 `let` 。

假设我们尝试使用 `let` 和 `lambda` 来定义一个递归的局部过程：

```scheme
(define (foo x)
   (let ((local-proc (lambda (y)
                        ...
                        (local-proc ...)   ; recursive call?  No.
                        ...))) 
      ...
      (local-proc x)
      ...)
```

这个例子的问题在于，在 loca-proc 里面的，看起来像是递归地 local-proc 调用实际上并不是递归。记住，`let` 首先计算变量的初始值，然后将变量的内存初始化，只有在之后绑定才会可见 —— 当进入 let体 之后。在上面的例子中，这意味着局部变量 local-proc 对于 lambda 表达式而言是不可见的。由 `lambda` 创建的过程不会看见它自己的名字 —— 在过程体中的名字 `local-proc` 会指向任意存在于外部环境中的 `local-proc` 的绑定，如果那里有的话。

块结构示意图可以把这个表示的更加清楚：

```
(define (foo x)
   (let ((local-proc (lambda (y)
                      +--------------------------+
                      | ...                scope |
                      | (local-proc ...)   of y  | 
                      | ...                      | )))
                      +--------------------------+
    +------------------------------------------+
    | ...                         scope of     |
    | (local-proc x)              local-proc   |
    | ...                                      | )
    +------------------------------------------+
```

不像 `let` ，`letrec` 在变量初始化之前就先创建了新绑定。内存被分配，名字的意思改变为指向新的局部变量绑定，在之后，这些变量的初始值被计算，变量会被初始化。

对大多数目的，这样做没有什么意义 —— 为什么你想要在变量的初始值被赋好之前就让变量绑定变得可见呢？然而，对于局部过程定义，这样很有意义 —— 我们想要使用`lambda` 来创建能够在之后，也就是被调用的时候，对变量进行操作。

`lambda` 创建了一个将要在`lambda` 表达式被求值的作用域中执行的过程，因此我们需要在`lambda` 表达式被求值之前使绑定可见。

如果我们在例子中使用`letrec` 而不是`let` ，那么它就是可行的。过程 `local-proc` 能够看见变量 `local-proc`，因此它能够通过它的名字调用它自己。

它的块结构示意图是这样的：

```scheme
(define (foo x)         +-----------------------------------+
   (letrec ((local-proc | (lambda (y)                       |
                        |  +--------------------------+     |
                        |  | ...                scope |     |
                        |  | (local-proc ...)   of y  |     |
                        |  | ...                      | ))) |
                        |  +--------------------------+     |
    +-------------------+                                   |
    | ...                                  scope of         |
    | (local-proc x)                       local-proc       |
    | ...)                                                  |
    +-------------------------------------------------------+
```

对 local-proc 的递归调用能够进行，因为调用存在于与方框对应的，变量 `local-proc` 的作用域中。

`letrec` 对于多重相互递归的局部过程也是可用的。你可以定义多个局部过程并让它们相互调用，像这样：

```scheme
(define (my-proc)
   (letrec ((local-proc-1 (lambda ()
                             ...
                             (local-proc-2)
                             ...))
            (local-proc-2 (lambda ()
                             ...
                             (local-proc-1)
                             ...)))
      (local-proc-1))) ; start off mutual recursion by calling local-proc-1
```

块结构示意图展示出，每个局部过程定义能够看见其他名字的绑定：

```scheme
(define (my-proc)
             +--------------------------------------------------------+
   (letrec ( | (local-proc-1 (lambda ()        scope of local-proc-1  |
             |                ...                and local-proc-2     |
             |                (local-proc-2)                          |
             |                ...))                                   |
             | (local-proc-2 (lambda ()                               |
             |               ...                                      |
             |               (local-proc-1)                           |
    +--------+               ...)))                                   |
    | (local-proc-1)                                                  | ))
    +-----------------------------------------------------------------+
```

你也可以在相同的 `letrec` 中定义普通变量，但`letrec` 对定义局部过程是最有意义的。

当一个 `letrec` 变量的初始值不是一个过程的时候，你必须小心注意，初始化表达式不能依靠任意其他的`letrec` 变量。像`let` 一样，初始化的顺序是未定义的。

例如，下面的片段是非法的：

```scheme
(letrec ((x 2)
         (y (+ x x)))
   ...)
```

在这种情况下，对计算 (+ x x) 的尝试会失败，因为 x 的值有可能没有被计算。对这个例子，`let*` 能够胜任 —— 第二个初始化表达式需要观察第一个表达式的结果，但反过来不一样：

```scheme
(let* ((x 2)
       (y (+ x x)))
   ...)
```

确保你理解了，为什么这样是合法的（原文为 illegal，疑似错误），但之前的例子中的 `lambda` 表达式是错误的。

当我们使用 `letrec` 和 `lambda` 创建递归过程时，`lambda` 表达式可以不必真正使用存储在绑定中的值而进行求值。我们能创建过程，这些过程将在调用时使用绑定中的值，但创建过程本身并不要求绑定具有值。它的确要求绑定是存在的，因为每个`lambda` 表达式都会创建一个过程，用来“捕获”当前可见的绑定 —— 改过程会记住它在被创建时的环境。

<h2 id = "8.7"> </h2>

#### 8.7.多重定义就像 letrec

既然你理解了 `letrec` ，我就可以解释`define` 的真正意义了。

注意，当你定义顶级变量和过程时，你创建的过程能够引用同在顶级环境中的其他变量。

这就好像是所有的顶级定义董事使用一个大的`letrec` 创建的，这样创建过程的初始值表达式就能够“看见”其他名字绑定。不是定义的表达式充当了假想`letrec` 的“体”。

回忆一下，用于定义过程的`define` 与定义变量的，且使用`lambda` 表达式计算初始值的`define` 是等价的。

下面的顶级形式

```scheme
...

(define (foo)
   (... (bar) ...))

(define (bar)
   (... (baz) ...))

(define (baz)
   (... (quux) ...))
...
(foo)
...
```

因此和下面的东西等价

```scheme
...

(define foo
        (lambda ()
           (... (bar) ...)))

(define bar
        (lambda ()
           (... (baz) ...)))

(define baz
        (lambda ()
           (... (foo) ...)))
...
(foo)
...
```

当我们将顶级定义视为隐式的`letrec` 部分时，程序的等价形式为

```scheme
(letrec (... 

         (foo (lambda ()
                 (... (bar) ...)))
         (bar (lambda ()
                 (... (baz) ...)))
         (baz (lambda ()
                 (... (foo) ...)))
         ...)
 ...
 (foo)
 ...)
```

（实际上，作用域就是这样形成的，但是 `define` 的初始值表达式和非定义的表达式是按它们出现在源代码中的顺序进行求值的。对顶级表达式，你可以依靠 Scheme 按照写下的顺序执行定义的可执行部分。）

局部定义也是以这样的方式工作的。一个 Scheme 解释器或编译器将任意出现在 体 的开头的定义视为隐式的`letrec` 的一部分；在相同 体 中的顺序表达式被作为隐式`letrec` 的 体。

所以，下面的过程

```scheme
(define (my-proc)
   (define (local-proc-1)
      ...)
   (define (local-proc-2)
      ...)
   (local-proc-1)
   (local-proc-1))
```

与

```scheme
(define (my-proc)
   (letrec ((local-proc-1 (lambda () ...))
            (local-proc-2 (lambda () ...)))
      (local-proc-1)
      (local-proc-2)))
If we "desugar" the outer define, too, we get 
(define my-proc
        (lambda ()
           (letrec ((local-proc-1 (lambda () ...))
                    (local-proc-2 (lambda () ...)))
             (local-proc-1)
             (local-proc-2)))
```

是等价的。

<h2 id = "8.8"> </h2>

#### 8.8.可变参数

在 Scheme 中，你能够轻易地写出带有可变数量参数的过程。从术语上看，被过程接受的参数的数量被称为过程的*元数* （arity），我们将能够接受可变数量参数的过程称为可变元过程。（variable arity procedure）

写出可变元过程的一种方法是使用由单个参数名称，而不是带括号的参数名序列的形式。这就告诉 Scheme ，当进入过程时，过程的实际参数应该被打包成一个表，这个过程会得到一个指向这个参数值表的参数。

例如，我们可以写出一个接受任意参数并打印传递给过程的参数表的过程。

```scheme
(define (display-all . args)
   (display args))
```

这里参数变量 `args` 接受了带有所有参数的表，然后我们使用 `display` 来打印这个表。如果我们像这样调用过程

```
Scheme>(display 'foo 3 'bar)
(foo 3 bar)
```

参数变量`args` 会被绑定并被初始化为表`(foo 3 bar)` ，表会被作为唯一参数传递给`display` 。一旦进入了过程，参数变量`args` 便没什么特殊的了 —— 它仅仅是持有被传递的参数的表罢了。

这样的机制对`lambda` 表达式同样适用。我们可以使用等价的变量定义方式来定义`display-all` ，这种方法的变量初始值明显是一个`lambda` 表达式：

```scheme
(define display-all
        (lambda args
           (display args)))
```

（注意到这个 lmabda 版本中，我们只使用了`args` 来作为参数限定，而不是`(args)` 。如果我们只使用了一个标识符，而不是带括号的标识符序列的话，Scheme 会将所有实际参数打包并以表的形式将它以但参数递给`display-all` 。这看起来和`define` 的版本不一样，但实际上要点相同 —— 我们使用变量`args` 来“代表”参数值序列，Scheme 把它表现为表。）

通常你会写出带有确定数量参数的过程，但它也能够接受更多参数。当你传递给过程多于过程需要的参数个数的参数时，Scheme 会将额外的参数打包成一个表，这个表被称为余表。（rest list）

Scheme 允许你使用这样的方式来表达出这一点：使用一个句点跟在通常的带括号参数序列后面，并在句点后面加一个参数来接收多余的参数表。（如果没有传递额外的参数，这个参数变量会接收一个空表。）

例如，假设我们想要使我们的`display-all` 接收至少一个参数，打印它，接着打印带有剩余参数的表。我们可以这样写：

```scheme
(define (display-all first . rest) 
   (display first) 
   (display rest))
```

这样一来，我们就可以定义出需要第一个参数并给它命名的过程。句点记号和表达不完整表的句点很像，它被用来表示：在句点之后的变量指向实际参数的”剩余“部分。\脚注 {考虑一个不完整表`(a b . c)` 。它的第一个元素是 `a` ，表的 `cadr` 是 `b` ，在这之后就是 `c` 。如果我们以这样的方式写出过程的参数声明，比如：(lambda(a b . c) ... )，我们就将形参`a` 想作”代表“第一个实际参数值，形参`b` 代表第二个实际参数值，形参 `c` 代表剩余的实际参数值。}可变元的一个普遍应用是允许可选参数的使用。例如，我们能够定义一个接收两个参数，并接受一个可选参数的过程`foo` 。如果可选参数没有被传递，我们可以将其默认为 `#f`。

```
(define (foo a b . rest) 
   (let ((c (if (null? rest); if no extra argument(s)
                #f  ; use default value #f for c 
                (car rest)))); else use first optional arg
     (bar a b c)))
```

这样的做法在进行 I/O 的函数中很常见，一个典型的的 I/O 操作会从某个文件读入或向某个文件写入 —— 就像标准输入和输出，或日志文件 —— 但 I/O 也可以通过显式使用*端口* 对象来对其他文件进行写入，就像文件句柄一样。（会在之后详细讨论端口。）如果没有端口来指明 I/O 操作的定向，那么它的定向应该是通常的文件。另一个通常应用是允许过程操作任意数量的参数。\[给出例子]

<h2 id = "8.9"> </h2>

#### 8.9.apply

过程 `apply` 允许你调用任意过程，并指定一个被作为参数传递的 value表，`apply` 接受一个过程和一个 value 表，并在之后使用这些参数对过程进行调用。

例如，`(apply + '(1 2))` 将 value 1 和 2传递给 `+` ，这个式子等价于`(+ 1 2)` 。

你很少会用到`apply`，因为普通过程调用在大多数情况下都能顺利工作。然而，偶尔地， 将过程应用于一个已经被计算好的 value 表是很方便的。（我会在\[第四章]中给出例子。）

<h2 id = "9"> </h2>

### 9.变量的再次绑定

#### 9.1.[标识符和变量](#9.1)

#### 9.2.[变量 vs. 绑定 vs. 值](#9.2)

到目前为止，我已经粗略地讲过了变量 持有 值（variables holding values），但这并不是很对。变量与内存绑定，而内存 持有 值。

我有时也粗略地谈取得”变量的值“，但实际上这是从当前环境，取得变量当前绑定的值的简写。

考虑当我们使用 `(define foo 10)` 定义变量 `foo` 的时候会发生什么。我们可以以这种方式画出变量的绑定：

```scheme
     +-----+

 foo |  *--+---> 10
     +-----+
```

准确的说的时候，我们说变量`foo` 绑定到左侧框所表示的内存位置。*绑定* 只是指将名字和其他东西联系起来。（”绑定“有几种含义 —— 这是一个很宽泛的词 —— 但在这本书中，我一般用它来讨论程序变量和实际内存之间的联系。）

为了简洁，我们将（内存的）位置视为变量的绑定，绑定实际上是名字与以它命名的内存之间的联系。

在 Scheme 术语中，我们将“绑定”和变量是分开来讲的，因为它们是两个不同的东西。在其他大多数语言中也是这样的（例如，C 和 Pascal），但通常人们不会明显的进行区分。他们会将程序变量视为变量，但他们也会将分配给某个特定东西的内存称为“变量”。一般地，有经验的程序员不会在这上面犯糊涂。

在这本书中，我尝试使用更加精确的方式，因为变量和绑定之间的区别在之后将要讨论的高级话题中是尤为重要的。就现在而言，放心吧，这里没有什么特别的 —— 当我区分变量和绑定的时候，这对于大多数编程语言都是适用的，不只是 Scheme。我只是对一些你可能已经知道的东西给出了名字。

（目前为止，我们还没有看到 Scheme 的变量和绑定真正特殊的地方，除了绑定中的值总是指针这一点。）

<h2 id = "9.1"> </h2>

#### 9.1.标识符和变量

孤立地说，像是`foo` 一样的文本标识符（名字）甚至并不是个变量。

程序的静态作用域结构赋予名字以某一层次的意义，程序的动态执行赋予它们更多的意义。

孤立地看，`foo` 没有任何意义。在程序中使用，它可以成为一个*变量* 的名字。在程序的不同为止，它可以称为不同*变量* 的名字，例如，一个顶级变量，或是在一个或多个过程中的局部变量。

在 Scheme 中，像是`foo` 一样的标识符可能并不是用来表示变量的。在`quote` 表达式`'foo` 和`'(baz foo bar)` 中，它标识了一个符号对象，以一种与变量绑定完全不同的意义。它并没有为变量`foo` 命名，或是绑定包含指向 `foo` 的指针的变量 —— 它是个指向唯一符号对象的指针的字面量形式的表示，这个唯一符号的打印表示为`foo` 。

<h2 id = "9.2"> </h2>

#### 9.2.变量 vs. 绑定 vs. 值

在 Scheme 中，对变量，绑定和值之间的区分是极其重要的，这一点对于理解解释器和编译器也是很重要的，因此我会花点时间来讨论这个东西。

区别在哪里？为什么不就直接说：变量持有值，也就是说，为什么不直接将内存单元曾为变量？因为，这是不对的。考虑下下下面的小程序。

```scheme
(define (double x)        ; define a procedure that doubles its argument
   (+ x x))            

(define (quadruple x)     ; define a procedure that quadruples
   (+ (double x)          ; its argument.
      (double x)))

(define (foo x)           ; define a recursive procedure that calls
   (if (> x 0)            ; itself if its argument is more than 0,
       (foo (- x 1)))     ; handing the recursive call an argument
                          ; that's one less.
```

我们定义了三个过程，`double`，`quadruple` 和`foo` ，它们中的每一个都有局部（参数）变量 `x` 。（所谓的参数变量就是以从过程调用处得到它的初始值的局部变量。）

因此，在以上的代码中有三个不同的变量 x，在每一个过程中，它都意味着不同的东西。每个过程都为 x 定义了不同的意义，每种不同的意义意味着不同的变量。

当我们谈论“在 `double` 中定义的 x” 和“在`foo` 中定义的 x ”时，两者的区别是很明显的。

我们可以改变变量的名字，来让每个变量拥有不同的名字，而不改变任何过程定义的原意。只要两个不同的变量具有相同的名称，我们就可以将其中一个变量更改为其他变量，只要我们将该变量作用域内的所有对它的引用都更改为该变量的新名称即可。

在上面的例子中，我们可以将每个变量 x 改成 x1，x2,，或 x3，并将在它作用域内所有对他的使用替换为新名字：

```scheme
(define (double x1)        ; define a procedure that doubles its argument
   (+ x2 x3))            

(define (quadruple x2)     ; define a procedure that quadruples
   (+ (double x2)          ; its argument.
      (double x2)))

(define (foo x3)           ; define a recursive procedure that calls
   (if (> x3 0)            ; itself if its argument is more than 0,
       (foo (- x3 1)))     ; handing the recursive call an argument
                          ; that's one less.
```

这样更清楚地表明了每个变量是不同的，但它并没有改变过程的行为，因为语言的作用域规则有着相同的效果。

同样要注意到，当定义过程时，并没有内存分配给过程的局部变量；过程中的变量 x 只是个定义 —— 除非被调用，空间是不会被分配给它们的。这就是绑定出现的理由了 —— 一些内存在运行时被分配并用于存储值。（原文：That's when binding happens，其中的 when 应为 why）

（记住，在其他语言中也是这样，即便人们没有明辨 —— 例如，在你进入一个过程是，一个 C 参数变量会被绑定，因为内存被分配给了它，参数名指向了内存。）

当我们管一些东西叫做“变量”时，这并不是因为我们可以对它赋值并改变它的值。上面的例子中，没有一个变量体现了这两点；没有一个过程对作为参数值进行修改。在一些语言，例如纯函数语言中，你根本找不到赋值，但这些语言中仍然有变量。

在编程术语中，“变量”和它在数学中的意义极其接近 —— 在不同的时候，对相同的过程进行调用，变量会指向不同的东西。例如，我可能使用参数 10 对 `double` 进行调用，在执行这个调用时，x 的值是 10。之后，我可能使用 500 调用 `double` ，在这个调用中， x 的值就是 500。

想一想这样的东西与逻辑中的变量的相似性。我可能使用这样的逻辑语句：“对所有的 x ，如果 x 是人，那么 x 就是不能永生的”。（Forall x , persion(x) -> mortal(x))。我可以使用同样的逻辑规则（语句）并将它运用于许多东西。

在我每次使用它的时候，x 可能会指向不同的东西，这一就是为什么它被称为变量。

使用变量并不意味着我在使用它时修改了它所指向的东西的状态 —— ；例如，Bill Clinton（比尔·克林顿）并不会因为我在推断他的某些事情而改变很多，我也很确定 Socrates （苏格拉底） 不会有什么改变。

这也并不意味着变量的意义是不是发生变化。如果我使用了上面的规则，并将它应用于苏格拉底，说“如果苏格拉底是个人，那么他就不是不死的”，x 指向苏格拉底 —— 这是重点。但我也可以说“如果克林顿是个人，那么他就不是不死的”。这时 x 指向了克林顿。在逻辑中，我们说，第一次 x 与苏格拉底绑定，并在这条规则中一致使用，在另一个例子中，我们说克林顿与 x 绑定，并在规则中一致使用。

这儿的要点在于，同样的变量可以在不同的时间指向不同的事物。这些不同的同时被称为“绑定”，因为变量在不同时间与不同的东西（绑定）产生联系。

想一想上面的递归过程`foo` 。在递归过程中，同样的变量可能在同一时间被绑定不同的东西。假设我使用参数 15 调用 foo，`foo` 将绑定它的参数 x 并将初始值 15 赋给绑定。之后它对该值进行测试，然后使用参数 14 进行自身调用。这个递归调用将它的参数 x 与 14 绑定，之后测试，并使用 13 对自身进行调用，之后也是这样。

在每一次递归调用中，一个 x 的新绑定会被创建，即便旧的绑定仍然存在，因为洗钱的调用还没有完成 —— 它们在递归期间被挂起。

当在同一时间存在多个绑定时，只有一个在过程执行时是“可见”的。例如，在一个递归调用的过程中，对于执行中的过程，只用一个绑定是“在作用域中的”（也就是可见的） —— 对应于该调用的绑定。我们管这个叫做变量的当前绑定。当调用返回时，先前的绑定再次变得可见，并变成当前绑定。

但是，变量究竟与什么绑定，或曰变量究竟指向什么？在 Scheme 中，它指向一篇内存。例如，当你调用过程时，每个参数变量都会与存储你传递的参数值的内存进行绑定。在你对过程的调用中，变量名会指向这一片内存。

一个 Scheme 绑定可能会因为赋值而随着时间的推移而持有不同的值，就像在大多数过程式（procedural）语言中一样。所以，不仅相同的变量可以与不同的内存绑定，不同的内存还可以持有不同的值。

一些人将对变量的绑定称为值，但在 Scheme 中（也在其他带有赋值的语言中）这并不是正确的，以这样草率的方式说话会造成误解。如果你分不清内存和值，你就对赋值了解的不够清晰。

一定记住下面的“一对多映射”：

-   一个名字（标识符）可以在一个程序中作为不同的变量，在不同的地方使用，或作为符号
    
-   一个给定的变量可能与不同的内存进行绑定，也就是指对相同过程的不同调用
    
-   一个给定的绑定可以持有不同的值，如果你对内存进行赋值和改变操作的话。
    

将这些东西弄明白的最好方法是考虑局部变量；顶级或全局变量是特殊情况，因为它们只有一个绑定。

顶级定义可能会在 变量/绑定/值 的区分时造成一些困扰，因为它们做了三件不同的事。它们定义了一个在一个作用域（顶级作用域）中可见的变量，它们将变量绑定给新的内存（创造顶级绑定），然后将内存使用初始值初始化。

==================================================================

This is the end of Hunk M. TIME TO TRY IT OUT At this point, you should go read Hunk N of the next chapter and work through the examples using a running Scheme system. Then return here and resume this chapter.

==================================================================

<h2 id = "9"> </h2>

### 9.尾递归

许多 Scheme 程序对递归有相当程度的依赖，在 Scheme 中能以在大多数语言中不可行的轻松方式使用递归。尤其是，你可以写出调用自身以代替的递归过程。

当一个过程以等价于迭代循环的方式调用自身时，Scheme 自动对它进行“优化”来使其不占用额外的栈空间。你可以在任何你在传统语言使用迭代的地方使用递归。术语上，像循环（loop-like)的递归被称为*尾递归*，我们会在后面的章节进行详细介绍。

尾递归的基本理念是，你永远不必向一个过程返回，如果所有的过程都将相同的值返回给它的调用者的话。例如，考虑下面的过程定义：

```scheme
(define (foo)
   (bar)
   (baz))
```

当我们调用 `baz` 时，它是一个尾递归，因为在接受 `baz` 的返回后，`foo` 除了向它的调用者返回之外，没有其他事可做。也就是说，`baz`向`foo` 的返回紧接着`foo`向它的主调者的返回。这实际上不需要两次返回，顺着`foo` 进行。取而代之的是，Scheme 在调用 `baz` 之前，避免了对`foo` 的状态的存储，因此`baz` 可以直接返回到`foo` 的主调者，而不必回到`foo`。

尾递归允许递归被用作循环，因为用于循环的尾部调用不会将主调者的状态保存在栈上。

Scheme 系统可以将尾递归实现为一种传递参数的 GOTO，而不保存调用者的状态。这样是不安全的，就行语言级别的 GOTO一样，因为它只会在与带有额外返回的结果相同时才会被执行优化。

一些语言的编译器，比如 Common Lisp 和 C 进行了一种受限的“尾递归优化”，但是 Scheme 对尾调用更加普遍和标准，因此你可以更加自由地在你的程序中使用递归，如果你的代码使用尾递归的话，就不用担心堆栈溢出的问题。

当然，你也可以像在大多数语言中一样使用递归，循环也可以，这样递归就可以做两件事。虽然 Scheme 具有传统的循环结构，但它们是使用递归定义的。

<h2 id = "11"> </h2>

### 11.宏

Scheme 是相当地面向过程的，但是过程不可能什么都能做，至少不总是以高效且语法上简洁的方式。

有时你想要定义你自己的控制结构和数据定义表达式，这些东西不能使用过程高效且准确地表达出来。对于这一点，Scheme 提供了语法拓展，或称之为宏的功能。

通过使用宏，你可以定义根据不同目的决定转变方式的定型代码。

你可能在其他语言中和宏有过糟糕的经历，比如 C，但是 Scheme 宏系统是特殊的。它对于抽象程序和以特殊的方式将东西放在一起有着强大的功效。

就像我们将在之后的章节看到的，使用 Scheme 宏，你可以高效地重整编译器来改变语言以及它的实现。这并不是你需要经常做的 —— 绝大多数时候你会和普通的编程和高阶函数相处的很好 —— 但是有时建立你自己的 Scheme 拓展版本来解决特定问题，或是自动化程序构造的繁琐和重复时，这时非常有帮助的。

<h2 id = "12"> </h2>

### 12.延续

Scheme 具有绝大多数语言都有的控制结构 —— 条件（if 语句），循环，和递归 —— 但它同时也有着一个非常特殊的，叫做 call-with-current-continuation 的控制结构。

（警告：call-with-current-continuation 很奇怪）

call-with-current-continuation 允许你保存计算的状态，将它打包程一个数据结构，然后去做其他的事情。不论何时，只要你想要的话，你可以重新恢复保留的状态，抛弃当前的计算并回到被保存的计算搁置的地方。

这比一般的过程调用和返回要强大的多，这也允许你实现像是回溯，多线程，自定义异常处理等高级控制结构。

大多数时候你都用不到 call-with-current-continuation，因为更传统的控制结构通常已经够用了。但如果你想要使用特殊的控制结构来自定义 Scheme 以解决特殊类型的问题，你可以通过使用 call-with-current-continuation 来解决。

<h2 id = "13"> </h2>

### 13.迭代结构

你可以注意到了，我们没有过多的讨论迭代结构。Scheme 的确引入了像是 `do` 的迭代结构，我们会在之后介绍这个，但相比于其他语言中的那样，你很少会使用它。一旦你习惯了它，通常递归用起来更容易。当你使用迭代结构时，你需要理解，它们只是递归的语法糖。

对大多数的目的，你可以像在其他语言中一样使用 Scheme 的迭代结构，但它们实际上是相当不同的。Scheme 的迭代结构实际上是尾递归的语法糖。任何可以用迭代做的事情，你都可以用递归，并且递归也允许你做迭代通常做不到的事情。

Scheme 的迭代结构和你可能习惯的那一个的主要区别在于循环变量在每一次迭代中并不是被更新。这并不意味着你没有循环变量 —— 不同点在于在每一次迭代中（尾递归），循环变量被重绑定了，而不是只绑定一次并在每一次迭代中更新（被赋值）。

（如果没有理解，不必担心 —— 会在递归这一章有个了断）

结果就是，当使用一等的过程和延续时，在每一次迭代中使用新的绑定是很方便的。例如，如果你在循环体中创建了一等过程，它会持续指向创建它的循环的变量绑定。

<h2 id = "14"> </h2>

### 14.讨论
~~the original website is empty......~~
