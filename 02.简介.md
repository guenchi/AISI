简介
===

在本章， 我会对 Scheme 的基础特性进行快速概括， 足够开始编写一些程序。

这章过的相当快， 简要介绍 Scheme 中大约一半的想法。在之后的章节中， 我会更加全面地解释和演示这些特性， 并介绍其他高级特性。

本章被打算是与下一章的前半部分同时阅读，下一章包含了对交互式使用 Scheme 的教程。当你应当翻看下一章的部分内容时，我会给出指示。在熟悉 Scheme 后，它将作为基础的参考内容。 你可以参考下一章中的基本示例，并在后面的章节中查找高级技巧。

如果你精通编程语言的概念，尤其是你在已经用 Lisp 编程，你可以轻松阅读这一章来了解 Scheme 是关于什么的。如果你精通编程语言的概念，直接阅读本节。

如果你想要在 Scheme 中实际编程， 你必须听从指示并阅读下一章的部分内容，而不是径直读完本章。

### 1. [Scheme 是什么](#1)：What is Scheme ?
### 2. [Scheme 基础特性](#2)：Basic Features of Scheme
### 3.[数据结构上的递归](#3)：Recursion Over Lists and Other Data Structures
### 4.[类型和相等判定](#4)：Type and Equality Predicates
### 5.[引用和字面量](#5)：Quoting and Literals
### 6.[局部变量和词法作用域](#6)：Local Valiables and Lexical Scpoe
### 7.[过程](#7)：Procedures
### 8.[再次绑定变量](#8)：Valuables, Bindings, and Values
### 9.[尾递归](#9)：Tail Recursion
### 10.[宏](#10)：Extending the Language
### 11.[延续](#11)：Continuations
### 12.[迭代构造](#12)：Iteration Constructs
### 13.[讨论](#13)：Introduction Discussion


<h1 id="1">

### 1. Scheme 是什么（Hunk A）

首先， 一堆行话 —— 不想看就忽略掉：

Scheme 是一种词法范围的， 块结构的， 动态类型的，大体上的函数式语言。它是 Lisp 的变体。它有带有块结构和不确定范围的第一等过程。它的参数按值传递， 但值就是引用。它有第一等 延续，允许构建新的控制抽象。它有词法范围（“卫生的”）宏，允许定义新的语法形式，或重新定义旧的语法形式。

如果这些现在对你毫无意义， 别担心， 继续读。

Scheme 被设计为一种交互性的和安全的语言。普通的 Scheme 系统是一个交互式程序，能让你按你想要的顺序运行 Scheme 程序的某些部分。当一个程序运行时，你的程序不只是终止， 你的数据不会消失 —— Scheme 会询问下一步做什么， 你可以检验数据或告诉 Scheme 去运行程序的另一部分。

Scheme 是安全的，因为交互式系统一般不会崩溃。如果你犯了个会导致系统崩溃的错误，Scheme 会发现它， 并询问你怎么做。它允许你检查和更改系统的状态，然后继续。这和普通的编辑 —— 编译 —— 链接 —— 运行 —— 崩溃 周期的“批处理”编程语言，比如 C 和 C++，相比，是一种非常不同的编程和调试风格。


<h2 id="2">

### 2. Scheme 基础特性

我会把一些 Scheme 基础特性简单地过一遍， 为清晰起见，只给出少量代码示例。

#### 2.1.[表达式](#2.1)：代码由表达式构成
#### 2.2.[布尔值](#2.2)：布尔值 #t 和 #f
#### 2.3.[其他控制结构](#2.3)：cond，and，和 or
#### 2.4.[注释](#2.4)：注释从分号开始直到行末
#### 2.5.[括号和缩进](#2.5)：关于括号和缩进的注解。
#### 2.6.[值皆指针](#2.6)：所用的值在概念上是指针
#### 2.7.[自动内存管理](#2.7)：Scheme 自动内存回收
#### 2.8.[动态类型](#2.8)：对象具有类型，而变量没有
#### 2.9.[空表](#2.9)：空表对象（），也叫做空指针


<h2 id="2.1">

#### 2.1.表达式

像 Lisp 一样，Scheme 也使用前缀表达式进行编写，使用括号进行分组。前缀意味着运算符的名称排在第一个，在运算对象（操作的内容）的前面。

在 Scheme 中，并没有对表达式（像是算术运算）和语句（像是 条件语句 或 循环语句 或 声明 ）的区分。它们都是“表达式” —— 从普遍意义上来说。

* ##### 2.1.1.[前缀表达式](#2.1.1)：带括号的前缀表达式
* ##### 2.1.2.[值和副作用](#2.1.2)：表达式会返回值，但可能有副作用
* ##### 2.1.3.[定义变量和过程](#2.1.3)：定义变量和过程
* ##### 2.1.4.[定义 vs 赋值](#2.1.4)：定义命名存储空间，赋值改变存储的值
* ##### 2.1.5.[大多数运算符都是过程](#2.1.5)：大多数运算符都是过程
* ##### 2.1.6.[特殊形式](#2.1.6)：特殊形式不是过程
* ##### 2.1.7.[控制结构是表达式](#2.1.7)：控制结构是带返回值的表达式


<h2 id="2.1.1">

##### 2.1.1.前缀表达式

在 C 或 Pascal 中，对带有参数 bar 和 baz 的过程 foo 的调用被写成：
```C
foo (bar, baz);
```
但在 Scheme 中，它被写成：
```scheme
(foo bar baz)
```
请注意，过程名和参数一起在括号里。习惯吧。如果你把它想成操作系统的一条 Shell 命令，比如，rm foo 或 dir bar —— 只是带上了括号分隔，它看起来就不会太奇怪了。

就像在 C 中一样， 表达式可以嵌套。下面是对过程 foo 的调用， 其中嵌套调用了过程表达式来计算参数。

```scheme
(foo (bar x) (baz y))
```

这几乎相当于 C 中的
```C
foo (bar(x), baz(y));
```
与 C 或 Pascal 一样，在实际调用过程之前，过程中的参数表达式会被求值；结果值被传递给过程。在 Scheme 术语中， 我们说该过程用于实际的参数值。

你很快就会注意到，Scheme 中的特殊字符非常少， 表达式通常用括号和空格分隔。例如，a-variable 是单个标识符，而不是不是减法表达式。在 Scheme 中，标识符不仅可以包含字母和数字，还有其他几种字符，例如 ! , ? , 和 _ 。长的标识符通常由短语构成，来清楚地说明它们的含义，使用连字符分割单词；例如，你可以有一个名为 list-of-first-ten-lists 的变量。你能够在一个标识符中使用像 + ，- ，* ， / 的字符，就像在 before-tax-total+tax 或 estimate-epsilon 中一样。

Scheme 对构建标识符规则宽松的一个后果是空格很重要。你必须在标识符之间输入一个或多个空格（或是回车），除非特殊字符（通常是括号）使划分明显。例如，加法表达式 (+ 1 a) 不能被写成 (+1 a) 或 (+1a) 再或是 (+ 1a) 。（它能被写成 ( + 1 a  )，因为在标识符之间额外的空格会被忽略）



<h2 id="2.1.2">

##### 2.1.2.值和副作用

Scheme 表达式结合了表达式和语句的特性。它们返回值，但它们也可以有副作用 —— 也就是说，它们能通过赋值改变变量或对象的状态。

在 Scheme 中，变量赋值操作是 set! ，读作“set-bang”。如果我们把 3 赋给变量 foo，我们这样写
```scheme
(set! foo 3)
```

这和 C 中的 foo=3; 非常像。
 
注意， (set! foo 3) 看上去像是函数调用，因为所有东西都使用前缀表达法，但这并不是一个真正的调用，这是另一种表达式。
 
你不应该在 Scheme 程序中使用太多赋值操作。就像我在之后解释的，这通常是不好风格的表现。我会展示怎样以一种不需要过多副作用的风格来编程。不过，如果你需要，它们就在那里。
 
当你编写一个修改参数值，而不仅仅是返回值的过程时，给它一个以感叹号结尾的名字是一种好的风格。这提醒你和任何读你的代码的人，该个过程改变已经存在的内容，而不仅仅是像一个新的数据结构一样返回一个值。大多数改变状态的 Scheme 标准过程都以这种方式命名。
 
但是，大多数 Scheme 过程不会修改任何东西。例如，标准过程 reverse 以表作为参数并返回反序的表。这就是说它返回了原始列表的反向副本，而没有修改原始列表。如果你编写了一个返回相同的表的过程，但以修改内容的方式使之反向，你最好称之为 reverse! 。这警告人们被传递给 reverse! 的表可能被改变。

另一个带副作用的过程例子是 display。display 取一个值，并将其以打印的形式写入屏幕或文件。如果你给它一个参数，它会写入“标准输出”；默认情况下，这是终端或其他展示方式。

例如，如果你想要给用户展示数字 1022 的打印表示，可以使用这个表达式

```scheme
(display 1022)
```

执行此表达式的副作用是将 1022 写在用户的屏幕上。（display 自动将数字转化为字符串，以便你阅读。）

注意到，display 并没有以感叹号结尾，因为它并没有对你提供的参数产生副作用。你可以给它一个数据结构，并确信它不会进行修改；display 当然具有副作用，但是 —— 它改变的是它写入内容的显示屏（或文件）的状态。

display 相当灵活，能够写入许多常见的 Scheme 对象的打印表示，甚至是相当复杂的数据结构。

除其他外，display 还能打印字符串。（字符串是另一种 Scheme 对象。你可以在双引号之间写出字符串字面量，“ like this”，Scheme 创建一个字符串对象来存储字符序列。

表达式 (display "hello world") 有写入"hello world"到标准输出的副作用，标准输出通常是用户的显示器。

这让 display 在调试程序、小的示例及编写交互式程序中显得非常有用。一个相似的过程，write 被用于在文件中保存数据；数据能通过使用 read 被拷贝回内存中。

在之后的章节，我会通过传递第二参数给 display，告诉它在何处输入，来展示如何写入文件。就现在而言，你只需要使用带一个参数的 display。不要尝试传递给 display 几个东西，并期望它全都打印出来。



<h2 id="2.1.3">

##### 2.1.3.定义变量和过程

可以使用 define 在 Scheme 中定义变量：
```scheme
(define my-variable 5)
```
这告诉 Scheme 为 my-variable 分配空间，并将存储初始化为 5。

在 Scheme 中，你总是给一个变量赋初值，这样一来就没有像是未初始化的变量或未初始化变量错误之类的东西了。

Schdme 的值始终是指向对象的指针，所以当我们使用字面量 5 时，Scheme 将其解释为指向对象为 5 的指针。数字是可以指向的对象，就像其他任何类型的数据结构一样。（实际上，大多数 Scheme 实现都使用了一些技巧来避免数字上的指针开销，但这并未在语言水平上显示。你不必注意它。）

在上述定义之后，我们可以像这样画出的结果情况：
```
    +-------+
foo |	*---|--->5		
    +-------+
``` 

define 表达式做了三件事：

* 它向 Scheme 声明，我们将在当前作用域中得到一个名为 foo 的变量。（我会在稍后讨论作用域。）
* 它告诉 Scheme 为变量分配存储空间。存储空间被称作绑定 —— 我们将变量 foo 与特定的一块内存“绑定”，以便我们能通过变量名 foo 来引用存储空间。
* 它告诉 Scheme 被放进存储空间的初始值。

当你在其他语言中定义变量时，这三件事也会发生。在 Scheme 中，我们为三者都起了名字。

在图中，盒子表示 Scheme 为变量分配存储空间的事实。在盒子旁的名字 foo 表示我们将存储空间命名为 foo。箭头表示盒子中的值是指向整数对象 5 的指针。（不要关心整数对象的实际表示方式，这一点都不重要。）

你也可以使用 define 来定义新过程：
```scheme
 (define (two-times x)
     (+ x x))
```
这里我们定义了名为 two-times 的新过程， 它需要一个参数 x。之后它调用加法过程 + 来使参数值与自己相加，并返回相加后的结果。

注意变量定义和过程定义之间的语法差异：对一个过程定义，名字两边有括号，参数跟在名字后面。

这和过程调用的方式很相似。考虑过程调用表达式 (two-times 5)，它返回 10；它和定义 (two-times x) 看起来很像，只是我们在形式参数 x 的地方使用了实际参数 5。

下面是一些你应该知道的编程语言术语：你传递给过程的参数有时被称为实参。在过程中的参数被称为形参 —— 它们代表在运行时实际传递给过程的任何内容。“实”意为你实际上传递给过程的内容，“形”意为你在过程内部调用的东西。通常我只说“参数”，但这和“实参”是同一个东西。有时我会讲到“参数变量”这和“形参”是一样的。

你可以定义不带参数的过程，但你仍然需要在过程名两旁加上括号，以表明你在定义一个过程。当你调用它时，也在名字两旁加上括号，来表明这是一个过程调用。

例如，这是一个变量定义，它的值是 15：
```scheme
(define foo 15)
```
但下面这个是过程定义，它在被调用时返回 15：
```scheme
(define (foo) 15)
```
```
    +-------+
foo |	*---|--->#<procedure>        
    +-------+
```
这张图展示了，当你定义过程时，你实际上定义了一个变量，它的值恰好是一个（指针指向的）过程。现在而言，你不必关心这个问题。需要知道的主要事情是，现在你可以通过名字 foo 来调用过程。例如，过程调用表达式 (foo) 会返回 15，因为该过程体做的就是返回 15 这个值。

通常，我们像这样缩进过程定义，过程内容在一个新的行，并缩进几个字符。
```
(define (foo))
	15)
```
这样更清楚地表明这是个过程定义。



<h4 id="2.1.4">

##### 2.1.4.定义 vs 赋值

请注意，我们可以用两种方式赋给变量一个值：我们能定义它，给一个初始值，或者使用 set! 来改变它的值。

两者的区别在于 define 为变量分配存储空间，并为其命名。 set! 不这样做。你必须在使用 set! 之前先定义一个供它作用的变量。

例如，如果没有定义变量 quux，表达式 (set! quux 15) 就是个错的，Scheme 就会抱怨。你请求 Scheme 将 15 （指针指向的）放到名为 quux 的存储空间中 —— 但 quux 并没有命名任何存储空间，所以这样做没有意义。

这就像我告诉你，“把这个给 Philboyd”然后给你一些物品，（比如，一支铅笔）。如果你不知道一个叫 Philboyd 的人，你可能会开始抱怨。set! 就是这样。我们必须在要求你为 Philboyd 做些什么之前，就“ Philboyd”是谁达成一致。define 是为标识符赋予意义的方式 —— 使它引用一块内存 —— 同时也给出存放的值。



<h2 id="2.1.5">

##### 2.1.5.大多数运算符都是过程

在传统的的编程语言中，比如 C 和 Pascal ，过程调用和其他种类的表达式中有着尴尬的区分。例如，在 C 中，(a + b) 是一个表达式，但是 foo (a, b) 是一个过程调用。在 C 中，处理过程时，你不能用像 + 之类的运算符做同样的事。

在 Scheme 中，事情在词义和语法上要统一的多。大多数基础运算，比如加法，都是过程，并且有着书写表达式的统一语法 —— 被括起来的前缀表示法。因此，你在 Scheme 中写 (+ a b)， 而不是 (a + b)。你会写 (foo a b)，而不是 foo(a, b)。不管哪一种，这都是带括号的，运算符后跟着运算对象的。

对任何过程调用表达式（也叫组合），所有要传递的值是在实际调用过程之前计算的。（这和 C 或 Pascal 没什么不同。）



<h2 id="2.1.6">

##### 2.1.6.特殊形式

虽然大多数操作都是过程调用，但你还需要了解其他几种表达式，它们的行为是不同的。它们被称作特殊形式。

过程调用和特殊形式在语法上很相似 —— 它们都是在括号中的语法单元，如 (foo bar baz)。然而，它们在语义上非常不同。这就是是为什么需你要了解特殊形式，不把它们和过程搞混的原因。

如果左括号旁的第一个东西是表明特殊形式的关键字，像是 define 或 set!， Scheme 会为这种表达式执行一些特殊的操作。如果不是，Scheme 将括号中的表达式视为过程调用，并以通常的过程调用的方式对其进行求值。

（这也是为什么特殊形式被称作“特殊形式” —— Scheme 将一些组合表达式视为需要做特殊处理，而不仅仅是过程调用。

你已经看到了 5 个或 6 个重要的特殊形式中的两个，define 和赋值运算符 set!。

注意，set! 并不是一个过程，因为它的第一个参数并不是一个被以通常方式求值、并作为参数传递的值的表达式。它是存放值的地址。（例如，如果我们写 (set! a b) ，我们得到 b 的值，并将它放入名为 a 的存储空间中。）

同样，define 特别对待它的第一个参数 —— 变量名或过程名不是一个被求值，并传递给 define 的表达式 —— 它只是个名称，你告诉 define 分配一些存储空间并使用这个名称。

我们将要看到的其他特殊形式包括：
* 控制结构： if，cond，和 case 和排序电路逻辑运算符（sort-circuiting logical operators）and 和 or
* 定义本地变量的形式：let 和它的变体 letrec 和 let*
* 循环结构：叫做 let 和 go
* quote 和 quasiquote，它们让你在代码中将复杂的数据结构作为文本字面量（textual literals）来编写
* lambda，用于以相当好用的方式创建新过程

也有一些非常特别的特殊形式，如 define-syntax，它允许你用“宏”定义你自己的特殊形式。



<h2 id="2.1.7">

##### 2.1.7.控制结构是表达式

Scheme 的控制结构是表达式，并返回值。if 表达式和 C 的 if-then 语句很像，但“then"分支和“else”分支也都是带返回值的表达式；if 表达式返回它求值的子表达式中的任何一个。

比如：
```scheme
(if (< a b)
	a
	b)
```

返回变量 a 或变量 b 的值，取决于谁小（如果相等，则返回 b 的值）。如果你熟悉 C 中的条件表达式，这就像是像是 (a < b) ? a : b 。在 Scheme 中，不需要 if 语句和类似 if 的三元运算符表达式, 因为 if“语句”是表达式。

注意，即使每一个表达式都有值，也并不需要用到所有的值 —— 你可以忽略掉 if 表达式的值。if 特殊形式因此可被用于控制执行的内容，或返回一个值，或同时使用两者。这取决于你。

返回值设定的一致性意味着我们从来都不必显式使用返回语句，因此 Scheme 没有它们。假设我们想要写一个返回两个数中的最小值的函数 min，在 C 中，我们可能这么写：
```C
int min(int a, int b)
{
	if (a < b)
		return a;
	else
		return b;
}
```
在 Scheme 中，我们可以这样做：
```scheme
(define (min a b)
	(if (< a b)
			a
			b))
```

不论取哪条分支，相应的变量（a 或 b)的值会被作为 if 分支的值返回，同时也是作为整个 if 表达式的值返回，这也作为过程调用的返回值。

当然，你也可以写不带 else 子句的单分支 if 。
```scheme
(if (some-test)
	(some-ation))
```

如果条件为假，单分支 if 的返回值是不确定的，如果你对返回值感兴趣，你应该使用两个分支的 if ，并显式确定两者应返回的东西。

注意到控制流是从上往下的，通过表达式的嵌套 —— if 控制着哪条子表达式被求值，这就像大多数语言中的控制语句的嵌套一样。值从表达式返回到调用方，像大多数语言中表达式的嵌套。

你可以使用 begin 写出其他表达式的有序序列，例如：
```scheme
(begin (foo)
	(bar))
```

先调用 foo 再调用 bar ，就控制流而言，一个 (begin ... ) 表达式非常像 Pascal 中的 begin ... end 块，或 C 中的 { ... } 块。（我们不需要一个 end 关键字，因为括回做了相同的工作。）

然而， Scheme 的 begin 表达式并不仅仅是代码块，因为它们是带返回值的表达式。begin 返回序列中的最后一个表达式的值。例如，上面的 begin 表达式返回调用 bar 返回的值。

过程的内主体像 begin 一样运作。如果其中包含几个表达式，它们会被顺序求值，而且最后一个表达式的值会作为过程调用的返回值。

下面是一个过程 baz， 它调用 foo,，然后调用 bar 并返回对 bar 的调用的结果。
```scheme
(define (baz)
	(foo)
	(bar)）
```
